---
title: 数据结构与算法基础——KMP
date: 2018-08-16 19:13:26
categories:
- 数据结构/算法
tags:
- KMP
---
# 数据结构与算法基础 —— KMP

KMP 是一种优化的模式匹配算法，区别于暴力模式匹配算法 O(mn) 的时间复杂度，KMP通过优化回溯问题，其时间复杂度可以优化至 O(m+n)。

## 朴素的模式匹配算法

![kmp1](../img/kmp1.gif)

可以发现，该算法在失配的时候会回退 i 值，造成时间复杂度增加，实际上在B和D失配的时候，子串是可以记录到D前一个字符串已经匹配成功的。

## KMP

![kmp2](../img/kmp2.gif)

我们先分析模式串——ABCAD，如果在D位置失配了，那么可以获取到一个信息，D以前的都成功匹配了，也就是说字符串失配位置前一个是A，恰好可以和模式串开头的A进行匹配。

## next数组

首先我们要知道，一旦发生失配，j需要移动到模式串的哪个位置。

|         |     |     |     |     |     |
| ------- | --- | --- | --- | --- | --- |
| 模式串  | A   | B   | C   | A   | D   |
| next[j] | -1  | 0   | 0   | 0   | 1   |

### 观察法

<small>*考研的时候做题用的方法</small>

先把第一第二个位置上的next标为-1,0，从第三位开始，观察模式串前部分和后部分相同的长度有多少(每次最多加1)，这么说可能比较抽象，举个栗子：
|     |     |     |     |     |     |  |
| --- | --- | --- | --- | --- | --- |--|
| 模式串 | A | B | A | B | C | A |
| next[j]| -1| 0 | 0 | 1 | 2 | 0 |

### JS实现

```javascript

function next(str) {
  let next = [-1]
  let len = str.length
  let k = -1
  let j = 0
  while (j < len - 1) {
    if (k === -1 || str[j] === str[k]) {
      k++
      j++
      next[j] = k
    } else {
      k = next[k]
    }
  }
  return next
}
```

