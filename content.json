{"meta":{"title":"用代码做画笔","subtitle":"童言无忌","description":null,"author":"朱童","url":"http://lynnjs.com","root":"/"},"pages":[{"title":"categories","date":"2018-03-22T15:02:17.000Z","updated":"2019-09-27T10:03:18.435Z","comments":true,"path":"categories/index.html","permalink":"http://lynnjs.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-03-22T15:06:39.000Z","updated":"2019-09-27T10:11:56.897Z","comments":false,"path":"about/index.html","permalink":"http://lynnjs.com/about/index.html","excerpt":"","text":"朱耀华中级前端开发工程师 北京，男，1996 年artzyh@163.com(+86) 176-0019-5193 简介 一年全职工作经验，两年在校项目经验 熟练使用 Vue, ECharts, jQuery 等 有较多的小程序开发经验 有 Koa / Express 开发经验 有 webpack / rollup.js 开发经验 计算机基础扎实 本科期间参与的项目获得2017年中国软件杯 特等奖 教育背景本科: 北京航空航天大学 软件工程2014 至 2018 工作经历北京国双科技有限公司 (2018.07 ~ 2019.03)前端开发工程师 Vue 技术栈项目开发； 小程序 mpvue 项目开发； 大数据可视化项目开发； 负责前端组项目的 CI / CD 部署。 要素式审判系统 ( 2019.01 ~ 2019.03 )通过提取并对比文书中”要素”等维度，为法官审判和定罪量刑提供大数据支持。 负责所有前端开发工作。 执法办案系统 ( 2018.12 ~ 2019.01 )提供一整套公安系统网上执法办案解决方案。 该项目还在开发初期，这两个月时间里 负责两个子系统的开发； 负责前端项目公共方法的抽取和打包（webpack / rollup.js）实现按需加载； 负责前端项目的 CI / CD 部署。 智慧党建 ( 2018.11 ~ 2018.12 )智慧党建是一个 CMS 系统，web 端管理内容、查看预览和统计信息，微信小程序查看内容。 负责该项目前端所有开发工作。高质量提测，已上线。 扶贫小程序 ( 2018.10 ~ 2018.11 )为地区扶贫政策中的帮扶责任人和帮扶管理员提供扶贫管理功能。 负责所有前端开发工作。已上线。 智讼微诉 ( 2018.08 ~ 2018.12 )为法院用户提供一套在线审判解决方案。web 端面向法官；PC 端面向法官；微信小程序面向法官和当事人，并提供网上庭审功能。已上线。 负责原生小程序到 mpvue 框架的迁移工作； 负责 3.0、3.1 版本迭代开发（执行在线和人脸核身迁移，web 和小程序）； 负责系统维护和 bug 修复。 市值管理系统 ( 2018.07 ~ 2018.08 )综合股市和企业的信息，为用户提供多种维度的比较结果。 负责中概股企业详情页面的开发。 基于 iOS 的北海救助局资产管理 APP ( 2017.12 ~ 2017.07 )毕业设计项目作为企业 ERP 系统的移动端补充，提供资产清点、单据填写 / 审批、资产管理等功能。 负责项目的设计和实现 基于 WiFi 探针室内定位的商业门店大数据分析系统 ( 2017.03 ~ 2017.07 )基于多个 WiFi 探针收集到的数据，为商业门店客户提供客流分析、客流统计、客流实时定位等功能。 负责前端的页面设计、接口设计和大部分实现。 获得 2017 年“中国软件杯”特等奖。 在校经历软件学院学生会文艺部执行部长 ( 2015.07 ~ 2016.07 )负责学院内各种晚会的组织和策划，多次策划并参与了较大型晚会（200人以上），担任总导演。 FooterGitHub: https://github.com/LynnScarlett Blog: https://lynnjs.com/"},{"title":"tags","date":"2018-03-22T15:01:44.000Z","updated":"2019-09-27T10:03:18.435Z","comments":false,"path":"tags/index.html","permalink":"http://lynnjs.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode Contest 128","slug":"LeetCode Contest 128","date":"2019-03-20T01:18:54.000Z","updated":"2019-09-27T10:03:18.428Z","comments":true,"path":"ck11ywqwg0004v8fyxe42g9gx/","link":"","permalink":"http://lynnjs.com/ck11ywqwg0004v8fyxe42g9gx/","excerpt":"","text":"LeetCode Contest 128LynnScarlettRank: 1307 / 5165Finish Time: 0:14:32Score: 6 1012. Complement of Base 10 Integer1012. Complement of Base 10 Integer 翻译：非负数 N，表示成二进制形式后取反，返回该十进制表示。 思路：用最接近 N 的 2 的 i 次幂-1，减 N。如：101 = 111 - 010 实现： 1234567891011/** * @param &#123;number&#125; N * @return &#123;number&#125; */var bitwiseComplement = function(N) &#123; let i = 1 while (N &gt; 2 ** i - 1) &#123; i++ &#125; return 2 ** i - 1 - N&#125; 1013. Pairs of Songs With Total Durations Divisible by 601013. Pairs of Songs With Total Durations Divisible by 60 翻译：一个数组中求两个元素相加能被 60 整除的数量。 思路：暴力遍历 实现： 123456789101112131415161718/** * @param &#123;number[]&#125; time * @return &#123;number&#125; */var numPairsDivisibleBy60 = function(time) &#123; let res = 0 for (let i = 0; i &lt; time.length - 1; i++) &#123; for (let j = i + 1; j &lt; time.length; j++) &#123; if (i === j) &#123; continue &#125; if ((time[i] + time[j]) % 60 === 0) &#123; res++ &#125; &#125; &#125; return res&#125; 1014. Capacity To Ship Packages Within D Days1014. Capacity To Ship Packages Within D Days 翻译： 有一个货物重量数组，要求在 D 天内运送完毕，从传送带一侧到另一侧需要用一天时间，求传送带最少需要支撑的重量 思路：遍历，从最大的货物重量，到货物总重量，进行二分查找 实现： 1234567891011121314151617181920212223242526272829303132/** * @param &#123;number[]&#125; weights * @param &#123;number&#125; D * @return &#123;number&#125; */var shipWithinDays = function(weights, D) &#123; let max = weights.reduce((x, y) =&gt; x + y) let min = Math.max(...weights) function binarySearch(start, end) &#123; let mid = Math.floor((start + end) / 2) let total = 0 let day = 1 for (let i = 0; i &lt; weights.length; i++) &#123; if (total + weights[i] &lt;= mid) &#123; total += weights[i] &#125; else &#123; total = 0 i-- day++ if (day &gt; D) &#123; if (start === end) return 0 return binarySearch(mid + 1, end) &#125; &#125; &#125; if (start === end) return start return binarySearch(start, mid) &#125; return binarySearch(min, max)&#125; 1015. Numbers With Repeated Digits1015. Numbers With Repeated Digits 翻译：求不大于 N 的正整数中，含有相同数字的数的个数 思路： 遍历（超时） 排列组合，详见：discuss","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://lynnjs.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://lynnjs.com/tags/LeetCode/"}]},{"title":"一些手写代码题（前端）","slug":"一些手写代码题（前端）","date":"2019-03-19T09:19:34.000Z","updated":"2019-09-27T10:03:18.429Z","comments":true,"path":"ck11ywqwj0006v8fyn9bzp7o6/","link":"","permalink":"http://lynnjs.com/ck11ywqwj0006v8fyn9bzp7o6/","excerpt":"","text":"一些手写代码题春天找工作，遇到了许多手写代码的场景，从基本数据结构（链表，二叉树），到实际应用的场景（闭包，并发），都有涉及。 闭包实现一个 repeat 函数问题描述：实现一个 repeat(fn, times, interval) 函数，使得 123let s = repeat(console.log, 5, 500)s(\"message\")// 输出 'message' 间隔0.5s 思路： 要注意多参数情况； 当 fn 耗时大于间隔时，下一次 fn 执行需要等待足够的 interval； 注意闭包函数实现时，不要修改内部的 times 和 interval。 实现： 123456789101112131415function repeat(fn, times, interval) &#123; return (...args) =&gt; &#123; let localTimes = times let timeout = () =&gt; &#123; setTimeout(() =&gt; &#123; localTimes-- fn(...args) if (localTimes) &#123; timeout() &#125; &#125;, interval) &#125; timeout() &#125;&#125; 实现一个 并发控制 函数问题描述： 实现一个函数 request(urls, max, callback)，实现发送 urls 数组里的请求，最大并发数为 max，所有请求结束后，调用 callback。 思路：首先看到所有请求结束之后的调用，首先想到的是Promise.all方法，但是这样实现并发比较困难。这里想的是 发送 max 个请求； 每个请求结束之后发起下一个请求； 当 urls 数组里没有待发请求的时候，调用 callback。 实现： 1234567891011121314151617function request(urls, max, callback) &#123; let localUrls = urls.slice() let called = false let req = () =&gt; &#123; fetch(localUrls.shift()).then(() =&gt; &#123; if (localUrls.length) &#123; req() &#125; else &#123; called = true callback() &#125; &#125;) &#125; for (let i = 0; i &lt; max; i++) &#123; req() &#125;&#125; 二叉树二叉树路径问题描述：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lynnjs.com/categories/JavaScript/"},{"name":"求职","slug":"JavaScript/求职","permalink":"http://lynnjs.com/categories/JavaScript/求职/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lynnjs.com/tags/面试/"}]},{"title":"正则表达式问题记录","slug":"正则表达式问题记录","date":"2019-03-14T13:28:10.000Z","updated":"2019-09-27T10:03:18.431Z","comments":true,"path":"ck11ywqxm001jv8fya2ioxl3r/","link":"","permalink":"http://lynnjs.com/ck11ywqxm001jv8fya2ioxl3r/","excerpt":"","text":"正则表达式问题记录Q1: 为什么正则表达式 第一次为 true，第二次为 false示例: 123let reg = new RegExp(/abc/gi)reg.test(\"abc \") // truereg.test(\"abc \") // false 这个问题的产生原因是：当有全局匹配标记时，每个正则表达式都有 lastIndex 属性，记录下一次匹配的位置，匹配过一次之后 lastIndex 没有归零。 以下是MDN对于 lastIndex 的解释： 只有正则表达式使用了表示全局检索的 “g” 标志时，该属性才会起作用。此时应用下面的规则： 如果 lastIndex 大于字符串的长度，则 regexp.test 和 regexp.exec 将会匹配失败，然后 lastIndex 被设置为 0。 如果 lastIndex 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 lastIndex 开始的字符串。（then the regular expression matches input starting at lastIndex.） 如果 lastIndex 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，lastIndex 被设置为 0.。 否则，lastIndex 被设置为紧随最近一次成功匹配的下一个位置。 解决办法： 去掉g标志; 在每次匹配之后将reg的lastIndex置 0。 此文不定期更新，用于记录","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lynnjs.com/categories/JavaScript/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://lynnjs.com/tags/Tips/"}]},{"title":"LeetCode Contest 127","slug":"LeetCode Contest 127","date":"2019-03-11T00:59:31.000Z","updated":"2019-09-27T10:03:18.428Z","comments":true,"path":"ck11ywqw50000v8fyehcs8cbp/","link":"","permalink":"http://lynnjs.com/ck11ywqw50000v8fyehcs8cbp/","excerpt":"","text":"LeetCode Contest 127从上周开始参加 LeetCode Contest。 LynnScarlettRank: 1806 / 4734Finish Time: 1:29:22Score: 13 1005. Maximize Sum Of Array After K Negations1005. Maximize Sum Of Array After K Negations 翻译：给定一个 Number 数组 A, 有 K 次机会进行操作A[i]=-A[i]，使得数组逐项求和最大。 思路: 负数从小到大消耗 K; 如果负数全部变成正数后，仍剩余K&#39;次，K 为偶数则跳过（因为偶数次翻转等于不翻转），K’ 为奇数则将排序后的 A 的最小值翻转。 实现： 1234567891011121314151617181920212223242526/** * @param &#123;number[]&#125; A * @param &#123;number&#125; K * @return &#123;number&#125; */var largestSumAfterKNegations = function(A, K) &#123; A.sort((a, b) =&gt; a - b) var i = 0 for (; i &lt; A.length; i++) &#123; if (A[i] &lt; 0 &amp;&amp; K) &#123; K-- A[i] = -A[i] &#125; else if (K === 0 || A[i] &gt;= 0) &#123; break &#125; &#125; if (K % 2 === 1) &#123; A.sort((a, b) =&gt; a - b) A[0] = -A[0] &#125; let sum = 0 for (let j = 0; j &lt; A.length; j++) &#123; sum += A[j] &#125; return sum&#125; 1006. Clumsy Factorial1006. Clumsy Factorial 翻译：给定一个数 n，把n!运算中的每个*运算符依次替换成* / + -循环，如：clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1，除法运算后直接取floor。 思路：clumsy(10)可以看成(10 * 9 / 8 + 7) - ( 6 * 5 / 4 - 3) - (2 * 1)。 实现： 123456789101112131415161718192021222324/** * @param &#123;number&#125; N * @return &#123;number&#125; */var clumsy = function(N) &#123; let clumsyRegion = (start, len, flag) =&gt; &#123; if (len === 1) return flag ? 1 : -1 if (len === 2) return flag ? 2 : -2 if (len === 3) return flag ? 6 : -6 if (len === 4) return flag ? Math.floor((start * (start - 1)) / (start - 2)) + (start - 3) : -Math.floor((start * (start - 1)) / (start - 2)) + (start - 3) &#125; let sum = 0 var i = N for (; i &gt; 3; i -= 4) &#123; sum += clumsyRegion(i, 4, i === N) &#125; if (i) &#123; sum += clumsyRegion(i, i, i === N) &#125; return sum&#125; 1007. Minimum Domino Rotations For Equal Row1007. Minimum Domino Rotations For Equal Row 翻译：两个 Number 数组 A 和 B，通过交换相同位置的 A 和 B 元素，使得 A 或 B 中各个元素相同，求最小操作次数。 思路： 先出现次数最多的元素 N，如果 N 出现的次数小于 A 的长度，那么无论如何交换都不会有完全相同的数组； 针对 N，遍历 A 和 B，维护两个数组 sumA 和 sumB，分别记录 A 和 B 变成完全相同数组需要的操作数； 如果A[i]!==N，sumA++，B 同理； 返回Math.min(sumA, sumB)。 实现： 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;number[]&#125; A * @param &#123;number[]&#125; B * @return &#123;number&#125; */var minDominoRotations = function(A, B) &#123; let dic = Array(7).fill(0) for (let i = 0; i &lt; A.length; i++) &#123; dic[A[i]]++ dic[B[i]]++ &#125; var j = 1 for (; j &lt; 7; j++) &#123; if (dic[j] &gt;= A.length) &#123; break &#125; &#125; if (dic[j] &lt; A.length) &#123; return 1 &#125; var sumA = 0 var sumB = 0 for (let k = 0; k &lt; A.length; k++) &#123; if (A[k] === j &amp;&amp; B[k] !== j) &#123; sumB++ &#125; else if (A[k] !== j &amp;&amp; B[k] === j) &#123; sumA++ &#125; else if (A[k] !== j &amp;&amp; B[k] !== j) &#123; return -1 &#125; &#125; return sumA &lt; sumB ? sumA : sumB&#125; 1008. Construct Binary Search Tree from Preorder Traversal1008. Construct Binary Search Tree from Preorder Traversal 翻译：通过前序遍历序列生成 BST。 思路：分治法，序列第一项为（当前子树的）根节点，序列后第一个比根节点大的开始为右子树，其余的为左子树。 实现： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;number[]&#125; preorder * @return &#123;TreeNode&#125; */var bstFromPreorder = function(preorder) &#123; if (preorder.length === 0) &#123; return null &#125; let mid = preorder[0] let tree = new TreeNode(mid) var i = 0 for (; i &lt; preorder.length; i++) &#123; if (preorder[i] &gt; mid) &#123; break &#125; &#125; tree.left = bstFromPreorder(preorder.slice(1, i)) tree.right = bstFromPreorder(preorder.slice(i)) return tree&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://lynnjs.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://lynnjs.com/tags/LeetCode/"}]},{"title":"深入理解HTTPS","slug":"深入理解HTTPS","date":"2019-03-08T06:09:26.000Z","updated":"2019-09-27T10:03:18.431Z","comments":true,"path":"ck11ywqxn001lv8fy4gw7d1ui/","link":"","permalink":"http://lynnjs.com/ck11ywqxn001lv8fy4gw7d1ui/","excerpt":"","text":"深入理解 HTTPS在春天的面试过程中，HTTP/HTTPS 作为网络基础的一部分，几乎个面试官都有问到。本文将从网络协议开始，分析 HTTPS 如何做到相对安全的网络传输。 TL;DR 使用数字签名、数字证书建立 SSL 连接 使用连接时的随机数生成对称密钥加密报文 HTTP 报文未经过加密的 HTTP 报文在传输时，主要面临三个问题 明文传输导致敏感信息泄露 易遭受 MitM 攻击 易遭篡改 而 HTTPS 在 HTTP 的基础之上，在应用层下的表示层进行 SSL 加/解密，使得明文信息受到保护。 加密方式常用的加密方式可以分成两种 对称密钥加密 非对称密钥加密（公开密钥加密） 对称密钥加密在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。优点是加解密速度快，缺点是双方需要获取相同秘钥。 非对称密钥需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。而且知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。优点是较为安全，只要私钥不泄露，传输就能保证单向的安全；缺点是加/解密速度较慢。 所以，HTTPS 的传输过程可以分成两步：1. 使用非对称密钥建立连接，交换生成对称密钥的必要信息；2. 使用生成的对称密钥加密 HTTP 报文。 数字证书与数字签名数字证书是由权威公正的第三方机构（CA）发放的身份凭证。 CA 机构内部有单独的一对非对称密钥，C 和 C’。私钥 C’保存在 CA 机构的服务器中，公钥则存在于每个浏览器的内部。 假设服务器 S 对应的域名为 S.com，S 首先在服务器内生成一对非对称密钥S 和 S’，妥善保存私钥，将公钥和其他必要的信息发送给 CA 进行认证。CA 核实确认 S 提交的信息无误后，把所有信息进行一次哈希运算，得到近乎唯一的字符串。再用 CA 的私钥C&#39;加密该字符串，得到的就是数字证书的数字签名，把以上信息合起来，就是 S 服务器的数字证书。 建立连接Client hello &amp; Server hello当客户端 B 发起 SSL 握手时，向服务器 S 请求证书并发送随机数，S 返回对应域名的数字证书、随机数和加密方式等等。 Certificate Request &amp; Certificate Verify客户端获取到证书，用浏览器内置的 CA 公钥 C，解密该证书的数字签名部分，同时对数字证书的其他部分做一次哈希运算，如果得到相同的字符串，则证明该证书没有篡改过，也就证明了该服务器的公钥是 S 的公钥。 Client Key Exchange客户端确认了数字证书的正确性之后，会用第一次握手获得的公钥S，加密一个随机数，发送给服务器。 这一过程是单向安全的，因为通过公钥 S 加密的数据，只有私钥 S’才能够解密。而私钥只保存在服务器中。这也就意味着无论是采用中间人攻击还是篡改，都无法威胁到这一次传输的正确性。 对称加密三次握手结束之后，连接双方分别采用商定的算法和三个随机数算出对称密钥K。此时的对称密钥是安全的，因为生成所用的随机数其中一个是绝对安全的，同时对称密钥也没有在网络上传输。 此后 SSL 链接都经过对称密钥加密，防止了中间人攻击和篡改。 参考链接 HTTP 权威指南 HTTPS – CSDN SSL 握手过程 –简书 对称密钥 – Wikipedia 非对称密钥 –Wikipedia","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://lynnjs.com/categories/前端基础/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://lynnjs.com/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://lynnjs.com/tags/HTTPS/"}]},{"title":"从零开始node（四）：工具","slug":"从零开始 node（四）：工具","date":"2018-10-21T11:06:45.000Z","updated":"2019-09-27T10:03:18.430Z","comments":true,"path":"ck11ywqxc0013v8fyg3lsm5g5/","link":"","permalink":"http://lynnjs.com/ck11ywqxc0013v8fyg3lsm5g5/","excerpt":"从零开始 node（四）：工具 工欲善其事，必先利其器。","text":"从零开始 node（四）：工具 工欲善其事，必先利其器。 Linux 下的安装在 Windows 和 macOS 平台，node 都有可视化界面来进行安装，在 Linux 平台就需要使用命令行来安装。常用的方法有以下几种： 包管理工具比如 ubuntu 的 apt，使用这种方法安装 node 的缺陷是版本不可控，且更新较慢。 下载源码编译安装使用这种方法需要一个单核能力较强的 CPU，由于我在日常开发的时候使用的都是云服务器，1Core1G 的配置使编译过程变得非常的长。 下载编译后的包使用 curl 或者 wget 工具在 nodejs 官网下载已经编译好的包，如https://nodejs.org/dist/latest/node-v10.12.0-linux-x64.tar.gz，解压后 cp 到/usr/local 即可使用。缺点是难以进行版本管理。 版本管理nvm/n n n 是一个 \bnpm 上的包，也就是说安装了 npm node 才可以安装 n，使用过程非常简单，只需一个命令n就可以使用上下箭头来切换 node 版本，而且切换版本的时候全局安装的包不受影响。缺点是不支持 Windows。 nvm nvm 是一个独立的软件，在*nix，macOS，Windows 都有稳定的表现，而且可以实现不同的终端窗口使用不同版本的 node。缺点是切换版本的时候全局安装的包也会随之切换。 守护进程从日常开发到正式部署上线，肯定不会采用node app.js的方法来启动 node 进程，因为随时有可能退出，并且会随着命令行窗口的关闭而关闭。在这里介绍三种守护进程用的包，supervisor/forever/pm2 supervisor一般用于开发环境，在保存代码后不用手动重启进程，supervisor 会自动重启，类似的还有 nest.js 脚手架默认使用的工具 nodemon。 foreverforever 是一个简单的工具，仅用于保持脚本持续运行，虽然它也有日志工具，但是在管理大型集群的情况下还是略显吃力。在我的使用历史来看，forever 守护博客最长曾经保持过两个月不宕机（不排除服务器不稳定的原因） pm2相比于前两种工具，pm2 就显得更加专业了，不仅可以守护进程，还可以做负载均衡、日志管理、状态监控等，满足了大型 node 项目的稳定运行。详细使用参见：pm2","categories":[{"name":"node","slug":"node","permalink":"http://lynnjs.com/categories/node/"}],"tags":[]},{"title":"从零开始 node（三）：多进程和集群","slug":"从零开始 node（三）：多进程","date":"2018-10-17T11:37:58.000Z","updated":"2019-09-27T10:03:18.429Z","comments":true,"path":"ck11ywqxk001dv8fygr6qcpi7/","link":"","permalink":"http://lynnjs.com/ck11ywqxk001dv8fygr6qcpi7/","excerpt":"从零开始 node（三）：多进程和集群在我们日常开发中，对于写好的 node 项目，使用node app.js即可启动。但是在大型项目，并发要求较高的情况下，单一的 node 进程不足以应对。 这篇博客从多进程和集群稳定性两个角度来分析 node 项目走向集群的原理。","text":"从零开始 node（三）：多进程和集群在我们日常开发中，对于写好的 node 项目，使用node app.js即可启动。但是在大型项目，并发要求较高的情况下，单一的 node 进程不足以应对。 这篇博客从多进程和集群稳定性两个角度来分析 node 项目走向集群的原理。 多进程Node 提供了 child_process 模块来创建子进程，通过调用 child_process.fork()来实现进程的复制。这种模式叫做Master-Worker模式，也叫作主从模式。主进程负责调度，工作进程处理业务。 这里要普及一下进程和线程的区别，进程占有资源（内存，总线，缓存，管道等），是操作系统进行资源调度的基本单位，是系统中一个互相较为独立的工作空间；线程占有的是 CPU 时间，在 CPU 调度中线程比较常见，线程不占有资源，存在于进程中。 也就是说两个线程互相通信需要额外的操作，实现进程间通信（IPC, Inter-Process Communication）的方法有很多，比如：命名管道，匿名管道，socket，信号量，共享内存，消息队列，Domain Socket等，Node 采用的是 IPC 管道，通过 libuv 抽象，windows 底层采用命名管道，*nix 系统采用 Unix Domain Socket 实现。在应用层面表现为 message s 事件和 send()方法。 来看一段创建多进程的例子： 1234567891011// parent.jsvar cp = require(\"child_process\")var child1 = cp.fork(\"child.js\")var child2 = cp.fork(\"child.js\")var server = require(\"net\").createServer()server.listen(80, function() &#123; child1.send(\"server\", server) child2.send(\"server\", server) server.close()&#125;) 12345678910111213// child.jsvar http = require(\"http\")var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;) res.end(\"handled by child, pid is \" + process.pid + \"\\n\")&#125;)process.on(\"message\", function(m, tcp) &#123; if (m === \"server\") &#123; tcp.on(\"connection\", function(socket) &#123; server.emit(\"connection\", socket) &#125;) &#125;&#125;) 在主从模式中，数据可以由主进程获取然后转发到各个进程中，但是这种方式并不高效。另一种方法是各个进程分别监听该端口，以抢占式处理请求。 在日常的开发过程中经常出现端口被占用的情况，所以在我们日常的认知中是一个端口只能由一个进程监听。事实上，多个进程是可以监听同一个端口的，只是由于我们分别启动进程监听端口时，socket 套接字的文件描述符各不相同，所以产生了错误。 Node 底层对每个端口监听都设置了 SO_REUSEADDR 选项，这个选项的涵义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同的进程复用。由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口时就会失败。但对于 send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。 集群本文从三个角度来简单介绍一下 node 集群管理需要注意的问题： 负载均衡 平滑重启 状态共享 负载均衡由于这些进程对于连接是抢占式的，也就是说，当连接进入端口时，所有进程都会被唤起，最终却只有一个进程能够获得连接，其他进程再次进入休眠。这种现象叫做惊群。 这时就需要主进程来决定连接的分配问题。 使用 pm2 和 nginx 可以方便的进行负载均衡，如： 1$ pm2 start app.js -i 4 来启动 4 个 app.js 进程。下一篇会有详细介绍 为此 Node 采用的策略叫Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在 N 个工作进程中，每次选择第 i = (i + 1) mod n 个进程来发送连接。在 cluster模块中启用它的方式如下： 1234// 启用Round-Robincluster.schedulingPolicy = cluster.SCHED_RR// 不启用Round-Robincluster.schedulingPolicy = cluster.SCHED_NONE 或者在环境变量中设置 NODE_CLUSTER_SCHED_POLICY 的值，如下所示： 12export NODE_CLUSTER_SCHED_POLICY=rrexport NODE_CLUSTER_SCHED_POLICY=none 大致类似于 CPU 调度的时间片轮转法。 平滑重启使用 pm2 的 reload 命令可以平滑的重启各个进程，也就是可以保证最少会有一个进程在工作中，而不是全部结束后重启。 自杀信号 在进程得知将要停止时，先向主进程发出“suicide”信号，主进程收到信号后会创建新工作进程来代替该进程，随后原进程处理完毕后即关闭。 限量重启 如果工作进程由于某些原因不断重启，可能会造成资源枯竭，这种频繁的重启有可能是由我们程序编写的原因造成的。如果在单位时间内进程重启超过一定次数，就会发出”giveup”事件,并放弃重启该工作进程。 状态共享解决数据共享最直接、简单的方式就是通过第三方来进行数据存储，比如将数据存放到数据库、磁盘文件、缓存服务（如 Redis）中，所有工作进程启动时将其读取进内存中。 实现状态同步的一种方案是各个进程通过轮询的方式来获取数据更新，这种方式显然不合适，占用了大量的资源。另一种方案是数据发生更改时主动通知各个进程，我们可以独立出来一个进程，通过轮询方式来判断状态的变化，一旦变化就主动通知进程变化。","categories":[{"name":"node","slug":"node","permalink":"http://lynnjs.com/categories/node/"}],"tags":[]},{"title":"从零开始 node（二）：Event Loop","slug":"从零开始 node（二）：Event Loop","date":"2018-10-11T09:37:19.000Z","updated":"2019-09-27T10:03:18.430Z","comments":true,"path":"ck11ywqyo003qv8fy4481mc40/","link":"","permalink":"http://lynnjs.com/ck11ywqyo003qv8fy4481mc40/","excerpt":"从零开始 node（二）：Event Loop朱耀华 第三、四章讲的是异步 I/O、异步编程，而实现异步的工具就是 Event Loop。在这里可以将浏览器环境和 Node 环境下的 Event Loop 对比来学习。","text":"从零开始 node（二）：Event Loop朱耀华 第三、四章讲的是异步 I/O、异步编程，而实现异步的工具就是 Event Loop。在这里可以将浏览器环境和 Node 环境下的 Event Loop 对比来学习。 首先看一个栗子： 123456789101112131415161718192021222324252627setTimeout(() =&gt; &#123; console.log(\"timer1\") Promise.resolve().then(function() &#123; console.log(\"promise1\") &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log(\"timer2\") Promise.resolve().then(function() &#123; console.log(\"promise2\") &#125;)&#125;, 0)// 浏览器环境// VM82:2 timer1// VM82:5 promise1// VM82:10 timer2// VM82:13 promise2// Node环境 v8.5.0// tick2.js:2 timer1// tick2.js:10 timer2// tick2.js:5 promise1// tick2.js:13 promise2 产生原因就在于两种环境下的 Event Loop 策略和过程不同。 浏览器环境下的 Event Loop浏览器环境下的异步操作分为两种：宏任务（macrotask）和微任务（microtask）。 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver 重点来了：在每一次 Event Loop 中，从宏任务队列中取出一个任务执行，该任务执行的过程中微任务的回调函数加入到微任务队列中，当宏任务执行结束，开始执行微任务，直到队列清空。再取出下一个宏任务重复以上操作。 举个栗子： 123456789101112131415setTimeout(function() &#123; console.log(1)&#125;, 0)new Promise(resolve =&gt; &#123; console.log(2) for (var i = 0; i &lt; 1000; i++) &#123; i == 999 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(function() &#123; console.log(4)&#125;)console.log(5)// 2 3 5 4 1 看懂这个你才算真正理解了浏览器端的 Event Loop。 流程分析： 首先从宏任务队列中取出一个任务即 script，顺序执行。 setTimeOut 立即执行（注意宏任务微任务区分的是回调），将回调函数加入宏任务队尾，继续执行。 new Promise 立即执行构造函数，输出 2，3，在循环 1000 次之后执行了 resolve，将 then 的回调函数加入微任务队尾。 输出 5，该宏任务执行完成，开始执行微任务队列，取出队首 then 的回调函数执行，输出 4。 微任务队列清空，取出宏任务队首的 setTimeOut 回调，输出 1。 这时我们来重新分析一下开始的栗子： setTimeOut1，2 分别加入宏任务队列。 script 执行结束，微任务队列为空，取出宏任务队列 setTimeOut1 的回调，输出 timer1，promise 加入微任务队列。 取出微任务队列队首，输出 promise1。 取出 setTimeOut2 的回调，输出 timer2，promise 加入微任务队列。 取出微任务队列队首，输出 promise2。 至此，浏览器端的 Event Loop 分析完成 Node 环境下的 Event Loop分析 Node.js libuv 库源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445int uv_run(uv_loop_t* loop, uv_run_mode mode) &#123; int timeout; int r; int ran_pending; r = uv__loop_alive(loop); if (!r) uv__update_time(loop); while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123; uv__update_time(loop); // timers阶段 uv__run_timers(loop); // I/O callbacks阶段 ran_pending = uv__run_pending(loop); // idle阶段 uv__run_idle(loop); // prepare阶段 uv__run_prepare(loop); timeout = 0; if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) timeout = uv_backend_timeout(loop); // poll阶段 uv__io_poll(loop, timeout); // check阶段 uv__run_check(loop); // close callbacks阶段 uv__run_closing_handles(loop); if (mode == UV_RUN_ONCE) &#123; uv__update_time(loop); uv__run_timers(loop); &#125; r = uv__loop_alive(loop); if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) break; &#125; if (loop-&gt;stop_flag != 0) loop-&gt;stop_flag = 0; return r;&#125; 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;──connections─── ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ timers 阶段：执行 timer（setTimeout、setInterval）的回调 I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调 idle, prepare 阶段：仅 node 内部使用 poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里 check 阶段：执行 setImmediate() 的回调 close callbacks 阶段：执行 socket 的 close 事件回调 可以这样理解：在 node 中每一个阶段都维护一个宏任务和微任务队列。在宏任务执行结束之后，执行一次微任务队列中的任务。在等待 I/O 的时候，node 线程会阻塞在 poll 阶段。 timers 阶段timers 阶段 Node 会检查 timer 是否已过期，如果有就把它的回调压入任务队列中执行。但是 js 的定时器并不靠谱，因为在定时器过期的时候，js 的线程可能会在执行另外一个任务。 setTimeOut 和 setImmediate 的执行顺序也是不固定的。如下： 1234567setTimeout(() =&gt; &#123; console.log(\"timeout\")&#125;, 0)setImmediate(() =&gt; &#123; console.log(\"immediate\")&#125;) 看起来任务是从 timers 阶段开始的，但是如果我们从 poll 阶段的 I/O 开始执行这段代码，就是 setImmediate 先执行，因为 poll 阶段之后就是 check 阶段，执行 setImmediate 代码。 poll 阶段当有已超时的 timer，执行它的回调函数。同步执行 poll 队列里的回调，直到队列为空或执行的回调达到系统上限，而后检查有无预设的 setImmediate()，分两种情况： 有预设的 setImmediate(),poll 阶段进入 check 阶段，并执行 check 阶段的任务队列； 无预设的 setImmediate()，阻塞在该阶段等待。如果 timer 队列非空，则开始下一轮事件循环，重新进入到 timer 阶段。 check 阶段setImmediate()的回调加入到 check 队列中顺序执行。 这时候文章开始的例子就比较容易理解了。我们对照着来看其他几个类似案例： 123456789101112131415161718192021222324252627// 加入两个setImmediate()的回调函数setImmediate(function() &#123; console.log(\"setImmediate延迟执行1\") // 进入下次循环 Promise.resolve().then(function() &#123; console.log(\"promise1\") &#125;) process.nextTick(function() &#123; console.log(\"nextTick1\") &#125;) process.nextTick(function() &#123; console.log(\"nextTick2\") &#125;)&#125;, 0)setImmediate(function() &#123; console.log(\"setImmediate延迟执行2\")&#125;, 0)console.log(\"正常执行\")//正常执行// setImmediate延迟执行1// setImmediate延迟执行2// nextTick1// nextTick2// promise1 两个 setImmediate 先执行，且nextTick队列优先清空，然后再执行其他队列。 至此，js 执行的两个环境的异步 Event Loop 执行顺序已经介绍清楚。大家可以自己动手来试试执行一下。 参考资料 深入浅出 Node.js 深入理解 js 事件循环机制（Node.js 篇） 知乎专栏 Node-libuv 源码 掘金技术征文","categories":[{"name":"node","slug":"node","permalink":"http://lynnjs.com/categories/node/"}],"tags":[]},{"title":"从零开始node（一）：模块机制","slug":"从零开始 node（一）：模块机制","date":"2018-10-09T11:18:10.000Z","updated":"2019-09-27T10:03:18.429Z","comments":true,"path":"ck11ywqx90011v8fy9ijjqakn/","link":"","permalink":"http://lynnjs.com/ck11ywqx90011v8fy9ijjqakn/","excerpt":"从零开始 node（一）：模块机制朱耀华 之前粗略的阅读过《nodejs 权威指南》，但是这本书有点类似于字典或者文档，比较重视核心模块和接口的使用。 这次从头开始阅读《深入浅出 Node.js》，也许这本书比较久远了，但是比较重视原理层面，适合仔细阅读。","text":"从零开始 node（一）：模块机制朱耀华 之前粗略的阅读过《nodejs 权威指南》，但是这本书有点类似于字典或者文档，比较重视核心模块和接口的使用。 这次从头开始阅读《深入浅出 Node.js》，也许这本书比较久远了，但是比较重视原理层面，适合仔细阅读。 node 中引入模块，需要经历三个步骤 路径分析 文件定位 编译执行 在 Node 中，模块分为两类：核心模块和文件模块。 核心模块是 node 提供的模块，在 node 源代码编译的过程中，编译进了二进制执行文件。在 node 进程启动时，部分核心模块就被直接加在今内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉。核心模块的加载速度是最快的。 文件模块是用户编写的模块在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程。 require()方法对相同模块的二次加载采用缓存优先的方式。 路径分析require()的参数——模块标识符分为以下几类 核心模块，如 http、fs 相对路径/绝对路径的文件模块 自定义的文件模块 自定义的文件模块查找策略是： 当前文件目录下的 node_modules 父目录下的 node_modules 逐级递归，知道根目录下的 node_modules 文件定位Node 会按照.js .json .node 的顺序给模块标识符添加扩展名，在文件定位的过程中是同步阻塞的，所以为标识符带上扩展名会加快速度。 有时候文件定位后得到一个目录，这时首先查找 package.json，从中取出 main 属性指定文件名定位。以上步骤失败则会把 index.js index.json index.node 作为默认文件名。 模块编译对于不同的文件扩展名，其载入方法也不同。 js 文件：通过 fs 模块同步读取文件后编译执行 node 文件：这是用 C/C++编写扩展文件，用 dlopen()方法加载最后编译生成的文件 json 文件：fs 同步读取后，JSON.parse()解析结果 编译成功的模块会将其文件路径作为索引缓存在 Module._cache 上。 JavaScript 模块的编译在编译的过程中，Node 对 JavaScript 文件内容进行了头尾包装，一个正常的 JavaScript 文件包装成如下： 123456;(function(exports, require, module, __filename, __dirname) &#123; var math = require(\"math\") exports.area = function(radius) &#123; return Math.PI * radius * radius &#125;&#125;) CommonJS 规范中存在着 require、exports、module、__filename、__dirname 这几个变量存在，就是由此而来，同事还对每个模块文件之间进行了作用域隔离。 *关于 exports 和 module.exports，exports 是对 module.exports 的引用，所以直接对 exports 赋值会造成指针丢失，并不会导出模块。 C/C++模块的编译node 文件是 C/C++编写编译后生成的，所以这一部分只有加载和执行，执行效率较高。 dlopen()方法在 windows 和*nix 平台有不同的实现，通过 libuv 兼容层进行封装。 JSON 文件的编译读取到内容之后，调用 JSON.parse()得到对象，将其赋给 exports。 内建模块：使用 C/C++编写，主要供其他模块使用的模块，比如 fs 模块。JavaScript 核心模块主要扮演的职责有两类：一类是作为 C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。 扩展模块：用户使用 C/C++编写的模块 *有关内建模块和扩展模块的编译和加载以后再讨论……","categories":[{"name":"node","slug":"node","permalink":"http://lynnjs.com/categories/node/"}],"tags":[]},{"title":"一个栗子引发的思考","slug":"一个栗子引发的思考","date":"2018-09-13T11:33:09.000Z","updated":"2019-09-27T10:03:18.429Z","comments":true,"path":"ck11ywqx7000zv8fym906eg5e/","link":"","permalink":"http://lynnjs.com/ck11ywqx7000zv8fym906eg5e/","excerpt":"一个栗子引发的思考前情提要：小 Foo 和小 Bar 是某互联网公司的同事。有一天，小 Foo 交给小 Bar 一个任务……","text":"一个栗子引发的思考前情提要：小 Foo 和小 Bar 是某互联网公司的同事。有一天，小 Foo 交给小 Bar 一个任务…… 轮询(Polling)小 Foo 说明任务之后并没有回到自己的工位，而是站在小 Bar 后边执行了以下方法： 123while (!Bar.getRes()) &#123; console.log(\"做完了吗？做完了吗？？\")&#125; 这就叫轮询 阻塞 (Blocking)小 Foo 说明任务之后并没有回到自己的工位，而是站在小 Bar 后边执行了以下方法： 123while (!Bar.getRes()) &#123; console.log(\"做完了吗？做完了吗？？\")&#125; 此时小 Foo 是阻塞的，因为 Foo 在等 Bar 的结果什么也没做。 非阻塞 (non-Blocking)小 Foo 说明任务之后并没有回到自己的工位，而是站在小 Bar 后边执行了以下方法： 12345while (!Bar.getRes()) &#123; Foo.play(\"炉石传说\").finally(() =&gt; &#123; console.log(\"做完了吗？做完了吗？？\") &#125;)&#125; 此时小 Foo 是非阻塞的，因为 Foo 在等 Bar 的时候还玩了炉石传说。 同步 (Synchronous)小 Foo 说明任务之后，小 Bar 说：“你先回去吧，做完我告诉你”，小 Foo 说：“不行，我就要在这看着你做！你做完了我才能玩炉石传说！”并执行了以下方法： 1234while (!Bar.getRes()) &#123; console.log(\"做完了吗？做完了吗？？\")&#125;Foo.play(\"炉石传说\") 此时的工作是同步的，因为只有 Foo Bar 做完了这个工作 Foo 才能玩炉石传说。 异步 (Asynchronous)小 Foo 说明任务之后，小 Bar 说：“你先回去吧，做完我告诉你”，小 Foo 说：“溜了溜了”，并执行了以下方法： 1234Bar.addEventListener(\"我做完了\", () =&gt; &#123; console.log(\"你总算做完了\")&#125;)Foo.play(\"炉石传说\") 此时的工作是异步的，因为这个工作还没做完，Foo 已经开始了下一个活动（玩炉石传说）。 并发 (Concurrent)小 Foo 说明任务 A 之后，发现自己还需要让小 Bar 做任务 B。 小 Bar 先做了任务 A，或者先做了任务 B，或者一会做任务 A 一会做任务 B，或者任务 A 任务 B 同时做，总之，在下班之前交付给了小 Foo。 此时的工作 AB 是宏观并发的，因为在同一时间间隔（下班之前）里，AB 被执行。 并行 (Parallel)小 Foo 说明任务 A 之后，发现自己还需要让小 Bar 做任务 B。 小 Bar 觉得自己非常厉害，所以他左手做任务 A，右手做任务 B。 此时的工作 AB 在某些时间点是并行，因为在一些时间点上，AB 是同时被执行的。 串行 (Serial)小 Foo 说明任务 A 之后，发现自己还需要让小 Bar 做任务 B。 小 Bar 觉得自己非常菜，所以精心规划好了工作时间，先做 A，然后做 B，最后检查一遍 A。 此时的工作 AB 是微观串行的，因为在同一时间点，只有一个工作被执行。 函数节流 (throttle)小 Foo 说明任务之后并没有回到自己的工位，而是站在小 Bar 后边执行了以下方法： 12let cui = () =&gt; console.log(\"做完了吗？做完了吗？？\")setInterval(cui, 1) 小 Bar 觉得小 Foo 这样做很不利于工作，于是给小 Foo 加了一层函数，这样小 Foo 无论怎么想催，一分钟最多催一次。 123456789101112131415161718192021222324var throttle = function(fn, interval) &#123; let _self = fn, timer, firstTime = true return () =&gt; &#123; let args = arguments, _me = this if (firstTime) &#123; _self.apply(_me, args) return (firstTime = false) &#125; if (timer) &#123; return false &#125; timer = setTimeOut(() =&gt; &#123; clearTimeOut(timer) timer = null _self.apply(_me, args) &#125;, interval) &#125;&#125;let cui = () =&gt; console.log(\"做完了吗？做完了吗？？\")throttle(cui, 1000 * 60)// 参考《JavaScript设计模式与开发实践》 这个方法叫做函数节流 函数防抖 (debounce)小 Foo 说明任务之后并没有回到自己的工位，他觉得小 Bar 写的太慢了，于是执行了以下方法： 1Bar.addEventListener(\"input\", () =&gt; console.log(\"做完了吗？做完了吗？？\")) 这样小 Bar 每输入一个字，就会听到小 Foo 全方位的“指导”。于是小 Bar 用了一个方法，每次自己停下来思考的时候，小 Foo 就会指导他。 12345678910function debounce(fn, interval = 300) &#123; let timeout = null return function() &#123; clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, interval) &#125;&#125;Bar.addEventListener(\"input\", debounce(() =&gt; console.log(\"做完了吗？做完了吗？？\"), 1000)) 这个方法叫做函数防抖，可用于：搜索框实时显示（不需要每输入一个字都进行一次搜索） 小Foo和小Bar的故事还在继续…… 朱耀华_20180913","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lynnjs.com/categories/JavaScript/"}],"tags":[]},{"title":"跨域和CORS","slug":"跨域和CORS","date":"2018-09-02T09:50:21.000Z","updated":"2019-09-27T10:03:18.434Z","comments":true,"path":"ck11ywqy2002jv8fyevwq93vy/","link":"","permalink":"http://lynnjs.com/ck11ywqy2002jv8fyevwq93vy/","excerpt":"跨域和CORS最近的一个项目在对接的时候，会报出以下错误： OPTIONS * 401()Failed to load *: Response to preflight request doesn’t pass access conreol check : No ‘Access-Conrtrl-Allow-Origin’ header is present on the requested resoutce. Origin ‘http://localhost:10001&#39; is not allowed access. 直译过来是 OPTIONS 请求错误，response 的 header 里面没有 ‘Access-Conrtrl-Allow-Origin’字段。 如果在开发过程中看到这个错误的话就可以直接截图给后端让他改了（虽然产生原因在浏览器……","text":"跨域和CORS最近的一个项目在对接的时候，会报出以下错误： OPTIONS * 401()Failed to load *: Response to preflight request doesn’t pass access conreol check : No ‘Access-Conrtrl-Allow-Origin’ header is present on the requested resoutce. Origin ‘http://localhost:10001&#39; is not allowed access. 直译过来是 OPTIONS 请求错误，response 的 header 里面没有 ‘Access-Conrtrl-Allow-Origin’字段。 如果在开发过程中看到这个错误的话就可以直接截图给后端让他改了（虽然产生原因在浏览器…… 同源策略同源是指三个相同： 协议 域名 端口 如果这三个中间有任何一个不相同，则称之为不同源。在浏览器中，如果源地址和目标地址不同源，则以下三种行为会受到同源策略限制： Cookie、LocalStorage 和 IndexDB 读取 Dom 获取 AJAX 请求 CORS但是在平时的开发过程中，本地使用的服务器是 127.0.0.1，当然和后端的服务器不同源。这时候就不可避免地进行跨域请求。目前在浏览器中对不同源的目标发送 XMLHttpRequest 或者 fetch 都会自动地进行 CORS（Cross-Origin-Resource-Share, 跨域资源共享)，用户和开发者使用起来和正常请求没有差别。 简单请求上面的错误就是 CORS 的其中一个过程，如果将要发出的跨域请求满足以下条件，那么就属于 CORS 定义下的“简单请求”： 请求方法是以下三种方法之一： HEAD GET POST HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求和普通的请求区别是会在头部加上一个 Origin 字段，如果指定的源不在许可的范围内，就不会返回一个包含’Access-Control-Allow-Origin’的字段，浏览器会报出上面的第二个错误。 非简单请求上面的第一个错误：OPTIONS 401()，显示是 OPTIONS 方法的请求返回了一个 Unauthorized 状态码。如果浏览器发出的跨域请求时非简单请求，那么就会先发出一个”preflight”(预检请求)，来检验源是否在服务器允许 CORS 的源列表内，如果返回的头部包含 Access-Control-Allow-Origin 字段而且值包含该源，那么浏览器会正常发出该请求。 那么现在错误原因已经很清晰了，首先由于 127.0.0.1 和服务器”不同源”，浏览器自动执行 CORS，非简单请求先发出 OPTIONS 预检，服务器返回的头部没有 Access-Control-Allow-Origin 字段，因此 options 报 401 错误。 解决办法：截图给后端（设置一下 Access-Control-Allow-Origin 添加 127.0.0.1 或者*（通配符） 有关于跨域的其他解决方案 JSONP、WebSocket，OPTIONS 请求返回的其他头部字段，请继续阅读参考资料中的博文。 参考资料 HTTP 访问控制（CORS）—— MDN 浏览器的同源策略——ruanyifeng 跨域资源共享 CORS 详解 HTTP 状态码——Wikipedia 朱耀华_20180902","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lynnjs.com/categories/JavaScript/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://lynnjs.com/tags/跨域/"}]},{"title":"深入理解 this","slug":"深入理解this","date":"2018-08-26T13:47:00.000Z","updated":"2019-09-27T10:03:18.432Z","comments":true,"path":"ck11ywqxq001sv8fy9fguevym/","link":"","permalink":"http://lynnjs.com/ck11ywqxq001sv8fy9fguevym/","excerpt":"深入理解 this这篇文章主要参考《你不知道的 JavaScript》的第2章—this全面解析 首先说结论： this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 本文使用了大量代码来说明，请耐心阅读。","text":"深入理解 this这篇文章主要参考《你不知道的 JavaScript》的第2章—this全面解析 首先说结论： this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 本文使用了大量代码来说明，请耐心阅读。 两种误解认为 this 指向”自己”123456789101112131415161718192021function foo(num) &#123; console.log(\"foo: \" + num) this.count++&#125;foo.count = 0for (let i = 0; i &lt; 10; i++) &#123; if (i &gt; 5) &#123; foo(i) &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9console.log(foo.count)// 0console.log(window.count)// NaN 上面代码中的 this 并没有按照预期指向“自己”（foo）。结果是在全局作用域下创建了 count 变量，但是由于没有赋值，count 为 undefined，而undefined++返回的是 NaN，NaN++同理，所以最后输出的是 NaN。 认为 this 指向“作用域”123456789function foo() &#123; var a = 2 bar()&#125;function bar() &#123; console.log(this.a)&#125;foo()// undefined this 并没有按照预期指向作用域也就是 bar=&gt;foo=&gt;window 这一作用域，而是输出了 window.a，也就是 undefined。 绑定规则this 的四条绑定规则分别是：默认绑定、隐式绑定、显式绑定和 new 绑定 默认绑定默认绑定是无法应用其他三条规则时的默认规则 123456789function foo() &#123; console.log(this.a)&#125;var a = 2/* 2 * foo在调用时使用的是没有任何修饰的函数引用，因此采用默认绑定。 */foo() 在函数嵌套调用的时候也会默认绑定到全局 12345678910111213141516function foo() &#123; var a = 2 console.log(this.a) bar()&#125;function bar() &#123; var a = 3 console.log(this.a) baz()&#125;function baz() &#123; var a = 4 console.log(this.a)&#125;var a = 1foo() 隐式绑定正常的隐式绑定的效果是这样的： 123456789function foo() &#123; console.log(this.a)&#125;var obj1 = &#123; a: 2, foo: foo&#125;obj1.foo()// 2 隐式丢失 1234567891011function foo() &#123; console.log(this.a)&#125;var obj = &#123; a: 2, foo: foo&#125;var a = \"window\"var bar = obj.foobar() // \"window\"//实际上是直接调用的foo() 简单来说就是，函数的传递是靠引用的，也就是“指针”，所以当bar = obj.foo的时候，bar 已经和 obj 没有关系了，直接指向原来的 foo 函数。这样的情况也会发生在函数作为参数传递到回调函数中的情况，使用时要注意。 显式绑定隐式绑定有一个缺陷，就是我们必须在一个对象内部包含一个指向函数的属性，显示绑定可以强制在某个对象上调用函数。在 function 类型的原型上都有 call()和 apply()方法。 12345678function foo() &#123; console.log(this.a)&#125;var obj = &#123; a: 2&#125;foo.call(obj)// 2 硬绑定 12345678910111213function foo() &#123; console.log(this.a)&#125;var obj = &#123; a: 2&#125;var bar = function() &#123; foo.call(obj)&#125;bar()// 2bar.call(window)// 2 硬绑定用于解决显式绑定下的绑定丢失问题。ES5 中提供了 Function.prototype.bind 方法用于硬绑定，返回一个硬绑定后的新函数。 new 绑定new 操作符在许多其他面向对象语言中都有，使用方法是myClass = new MyClass()，从而调用类的构造函数。但是在 JavaScript 中并不存在什么“构造函数”，只有对于函数的“构造调用”。使用 new 操作符调用函数时会执行以下操作： 创建新的对象，相当于创建字面量{} 构造函数指向 new 的函数 this.constructor = foo 该对象的原型链接到 Foo.prototype 新对象绑定到函数调用的 this 传入的参数赋给新对象 123456function foo(a)&#123; this.a = a&#125;var bar - new foo(2)console.log(bar.a)// 2 优先级这四种规则的优先级，默认绑定是最低的。 显式绑定 &gt; 隐式绑定 1234567891011121314151617function foo() &#123; console.log(this.a)&#125;var obj1 = &#123; a: 2, foo: foo&#125;var obj2 = &#123; a: 3, foo: foo&#125;obj1.foo() // 2obj2.foo() // 3obj1.foo.call(obj2) // 3obj2.foo.call(obj1) // 2 显然，通过显示绑定调用已经隐式绑定的函数，最终的效果是显式的效果。 new &gt; 显式绑定 1234567891011function foo(something) &#123; this.a = something&#125;var obj1 = &#123;&#125;var bar = foo.bind(obj1)bar(2)console.log(obj1.a) // 2var baz = new bar(3)console.log(obj1.a) // 2console.log(baz.a) // 3 new 操作符会检测硬绑定，并用新创建的 this 替换。 应用：预置参数 123456function foo(p1, p2) &#123; this.val = p1 + p2&#125;var bar = foo.bind(null, \"p1\")var baz = new bar(\"p2\")baz.val //p1p2 总结 使用了 new ? 绑定到新创建的对象 通过 call,apply 调用 ? 绑定到指定的对象 通过对象隐式调用 ? 绑定到该对象 使用默认绑定，严格模式下绑定到 undefined 箭头函数箭头函数并不会应用以上四条规则，而是直接继承外层函数的 this，和平时用的var me/self/that = this一样的效果。（真香警告 参考文献 《你不知道的 JavaScript》 《JavaScript 专家编程》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lynnjs.com/categories/JavaScript/"}],"tags":[{"name":"this","slug":"this","permalink":"http://lynnjs.com/tags/this/"},{"name":"Note","slug":"Note","permalink":"http://lynnjs.com/tags/Note/"}]},{"title":"读《JavaScript专家编程》","slug":"读《JavaScript专家编程》","date":"2018-08-22T12:02:50.000Z","updated":"2019-09-27T10:03:18.432Z","comments":true,"path":"ck11ywqxt0020v8fy79mhmgo5/","link":"","permalink":"http://lynnjs.com/ck11ywqxt0020v8fy79mhmgo5/","excerpt":"","text":"读《JavaScript 专家编程》《JavaScript 专家编程》这本书刚开始读的时候有种能读一个月的错觉。但是实际上不到一周时间就读完了，原因在于这本书有点“头重脚轻”，前面讲的挺透彻，越到后面越放飞自我……再加上年代久远，有些工具已经不适用了，而且其中的一些有关于测试的内容还是在软件工程类别的书里深入了解吧。 第 1 章 对象和原型对象概述 configurable：设置为 false 的时候，属性的描述符会被锁定，无法修改。 enumberable：设置为 false 的时候，属性不可以被遍历（阻止遍历，不是被隐藏起来） writable：设置为 false 的时候，属性的值不可被改变 检视对象： 12345678910111213141516171819202122232425262728293031323334// 1. 返回对象属性特性的配置Object.getOwnPropertyDescriptor(\bo,'foo')// 2. 返回对象全部属性的名字，包括那些不能枚举的Object.getOwnPropertyNames(o)// 3. 用来返回特定对象的原型，有时可以使用__proto__代替，但是仅可访问，设置时需要__proto__Object.getPrototypeOf(o)// 4. 分辨某个属性是否存在与对象实例中Object.hasOwnProperty('foo')// 5. 返回可枚举属性Object.keys()// 6. 如果对象不能扩展，属性也不能修改，返回trueObject.isFrozen()// 7. 这个方法在对象额整个原型链中检查每一环，看传入的对象是否存在于其中Object.isPrototypeOf()// 8. 使用Object.preventExtensions('o')来禁止扩展Object.isExtensible()// 9. 对象不可扩展&amp;&amp;属性都不可配置Object.isSealed()// 10. 使用一个基本类型的值来描述对象Object.valueOf()// 11. 与严格相等运算符类似，不需要强制转换时是否具有相同的值// console.log(NaN===0/0) false// Object.is(NaN,0/0) trueObject.is(foo,bar) 修改对象 区分几个概念： freeze：增/删/改seal：增/删preventExtensions：增 创建对象 1234567891011121314var foo = &#123;&#125;/** new的四个步骤 * 1. 创建新的对象，相当于创建字面量&#123;&#125; * 2. 构造函数指向new的函数this.constructor = foo * 3. 该对象的原型链接到Foo.prototype * 4. 传入的参数赋给新对象 * 之前看过new的三个步骤版本，以后整理 */var bar = new Object()// 可以接收参数作为新创建对象的属性var baz = Object.create() 原型的访问方式 123Foo.prototypeObject.getPrototypeOf(foo)Foo.__proto__ 第 2 章 函数第 3 章 闭包第 4 章 强转 JavaScript 尝试将对象转换成字符串时，首先调用 toString()方法。如果不反悔基础类型，会调用 valueOf()函数。否则抛出 Typeerror 异常。转为数字时顺序相反。 12345console.log(\"1\" + 1) // \"11\"console.log(+\"11\") // 11console.log(+new Date())console.log(new Date() + \"\") 在对象的原型链上定义 toString()和 valueOf()来定义强转时使用的函数，但是会出现先调用 valueOf()的情况。原因在于内部的机制：如果一个对象能够转成多个基础类型，那么会使用可选参数PreferredType来指定类型。由于没有指定内部默认值（DefaultValue）函数，JS 假设你想要一个数字。 数组的 valueOf()方法返回一个对象。 ‘||’默认值、!!获得 Boolean 类型 立即调用函数表达式，前面加上一元运算符会把函数声明转成函数表达式，可以在后面接上括号进行调用。在写类库框架的时候常常把分号前置，以防止解析器意想不到的错误。 1234567function foo()&#123; console.log('这是一个函数声明')&#125;() //报错!function bar()&#123; console.log('OK')&#125;() >&gt;&gt;逻辑右移运算符，正负均补 0 ，详见计算机组成原理一书。 - 1;(false + [])[0] === \"f\" // true 堆：堆是在内存中的顺序无关的容器，存放正在使用或未被垃圾回手清理的变量和对象的地方 帧：帧是时间循环周期中需要被执行的连续工作单元。帧包含把函数对象和堆中的变量链接在一起的执行上下文。 栈：事件循环栈包含了执行一个消息所需的所有连续的帧，事件循环自顶向下处理帧，有以来的帧把他们所依赖的帧添加到上面。 队列：队列是等待处理的消息的列表，每条消息都引用一个函数。当栈为空时，队列中最旧的消息作为底部帧被添加到栈中。 有关宏任务微任务可以看这个简单了解一下。 第 7 章 风格 变量名、函用 camelCase，类使用 PascalCase，匈牙利命名法不是必须的，可用于表达对象是依赖于一个库或者框架构造的。 多线程web worker","categories":[{"name":"Notes","slug":"Notes","permalink":"http://lynnjs.com/categories/Notes/"}],"tags":[{"name":"Reading","slug":"Reading","permalink":"http://lynnjs.com/tags/Reading/"},{"name":"Software Engineering","slug":"Software-Engineering","permalink":"http://lynnjs.com/tags/Software-Engineering/"}]},{"title":"数值的表示","slug":"数值的表示","date":"2018-08-17T00:33:27.000Z","updated":"2019-09-27T10:03:18.431Z","comments":true,"path":"ck11ywqxi001av8fy5k6qn8ox/","link":"","permalink":"http://lynnjs.com/ck11ywqxi001av8fy5k6qn8ox/","excerpt":"","text":"数值的表示 本文首先发布于国双前端 先上代码 123// JavaSctipt// 0.30000000000000004console.log(0.1 + 0.2) 如果你百度一下，就会知道几乎所有语言都会面临浮点数的精度问题，想要了解 IEEE754，要先了解计算机内部的定点数表示法。 定点数以八位机器数举例 原码1210 =&gt; 0000 1010-10 =&gt; 1000 1010 原码就是把数值直接用二进制表示出来，正负号用末位 0，1 来表示。原码有诸多弊端，比如：数值的减法不能用加法来计算。在十进制中 10-10 和 10+(-10)是等效的，但是在原码表示法的机器数运算中，10+(-10)却得到了 1001 0100 的结果，显然不等于 0 。在计算机内部，处理运算是用与或非门来控制的，加减法分别用两套电路有些浪费资源，我们能否用加法电路来实现减法呢？其次，0 和-0 在原码中竟然是不同的表示法，但是这对运算并没有帮助，反而浪费了一个表示位置。 补码1210 =&gt; 0000 1010-10 =&gt; 1111 0110 补码的正数和原码一样，但是负数采用原码的“取反加一”，也就是说，想要得到-10，首先把符号位确定为 1，然后写出 10 的原码表示，将其各个位置取反加一，即得到了该原码的补码。补码的求相反数同理。 此时 10+(-10)和 10-10 的操作统一了，同时也没有了+0 和-0 的区别。计算机内部运算一般采用补码来进行，感兴趣的可以了解一下定点数/浮点数的乘法/除法，仅用移位和加法运算即可完成。 补码的移位要注意一点，算术右移的时候正数补 0 负数补 1 。 移码、反码此处不涉及，了解即可。 浮点数为了扩大数的表示范围，可以采用“科学计数法”来表示大数或者小数。比如-2000 0000 就可以表示成 1-1 * 2 * 10 ^ 7 如果我们提前约定好了底数 10，那么我们表示这个数只需要三个信息，负号、2、7 ，转换成 2 进制就是 1 10 0111 比我们单独存储-20000000 要节省很多空间 由于 2 进制的限制，计算机内部这个约定好的底数是 2。 IEEE754目前计算机内部表示浮点数的一个标准就是 IEEE754，以 32 位计算机举例，表示 1100 0111 为 1 1000 0101 10001110000000000000000乍一看可能觉得这种表示法更复杂了，其实无论在精度还是在表示数的范围，IEEE754 都是很优秀的。在 IEEE754 中，底数为 2，用 1 位表示符号，8 位表示阶码，也就是上文中的 1000 0101，为了表示 2 的负数次方，阶码采用移码，都加上 127，这样负数的阶码也可以表示出来了，23 位原码表示尾数。关于尾数这里要注意一点，由于 2 进制的有效数字第一位一定是 1，所以尾数的前面省略了一个 1 不写，用 23 位的尾数表示了 24 位的值，在手动转换的时候要自己补上。 说了这么多还是没有直接解答浮点数的精度问题，但是看过了以上之后，你会更容易理解。首先计算机没有办法精确地表示 0.1 和 0.2 等等，因为通过 2 次幂来控制移位，计算机只能精确表示出 0.5、0.25、0.125、0.0625 等等，这些数是无论如何也不能表示出 0.1 这样的数的，只能随着尾数长度的增加而无限接近。而在计算机存储这样的数的时候就会用到舍入策略： 舍入策略IEEE 列出了四种不同的舍入方法： 舍入到最接近：舍入到最接近，在一样接近的情况下偶数优先（Ties To Even，这是默认的舍入方式）：会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中式以 0 结尾的）。 朝+∞ 方向舍入：会将结果朝正无限大的方向舍入。 朝-∞ 方向舍入：会将结果朝负无限大的方向舍入。 朝 0 方向舍入：会将结果朝 0 的方向舍入。 举个栗子假如我们都采用朝+∞ 方向舍入，保留一位小数，那么 0.41 会入到 0.5，0.41+0.41 在计算机中就会计算成 1.（仅仅是假设，实际计算机精度大得多）而在我们 let a = 0.3 的时候会把 0.3 转换成 2 进制存储进来，再进行读取的时候，由于它和 0.3 的差比机器内部最大舍入误差小，所以再进行输出的时候就会正常输出 0.3，在进行 0.1+0.2 的时候由于这种舍入误差的累积，导致了输出结果不等于 0.3 。 不同语言的输出123456789// C#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; printf(\"%f\",0.1+0.2); return 0; // 0.300000&#125; 1234567// javapublic class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(0.1+0.2); // 0.30000000000000004 &#125;&#125; 123# pythonprint 0.1+0.2# 0.3 12345// php&lt;?php echo 0.1+0.2 // 0.3?&gt; 123# rubyputs 0.1+0.2# 0.30000000000000004 不同语言由于在输出长度方面有区别，所以最后的 4 可能会被截断。 浮点数比较在日常使用中一般不建议浮点数进行比较，一种比较的方法是： 12abs(a - b) ＜ 1e-8// 自行设置精度 参考链接IEEE 754_wikipedia深入理解计算机系统(原书第 3 版)计算机组成原理-唐朔飞js 中浮点数的表示及计算–IEEE 754原码补码反码移位","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://lynnjs.com/categories/计算机组成原理/"}],"tags":[{"name":"IEEE754","slug":"IEEE754","permalink":"http://lynnjs.com/tags/IEEE754/"}]},{"title":"数据结构与算法基础——KMP","slug":"数据结构基础：KMP算法","date":"2018-08-16T11:13:26.000Z","updated":"2019-09-27T10:03:18.431Z","comments":true,"path":"ck11ywqxl001gv8fy8s25d2bu/","link":"","permalink":"http://lynnjs.com/ck11ywqxl001gv8fy8s25d2bu/","excerpt":"","text":"数据结构与算法基础 —— KMPKMP 是一种优化的模式匹配算法，区别于暴力模式匹配算法 O(mn) 的时间复杂度，KMP通过优化回溯问题，其时间复杂度可以优化至 O(m+n)。 朴素的模式匹配算法 kmp1 可以发现，该算法在失配的时候会回退 i 值，造成时间复杂度增加，实际上在B和D失配的时候，子串是可以记录到D前一个字符串已经匹配成功的。 KMP kmp2 我们先分析模式串——ABCAD，如果在D位置失配了，那么可以获取到一个信息，D以前的都成功匹配了，也就是说字符串失配位置前一个是A，恰好可以和模式串开头的A进行匹配。 next数组首先我们要知道，一旦发生失配，j需要移动到模式串的哪个位置。 模式串 A B C A D next[j] -1 0 0 0 1 观察法*考研的时候做题用的方法 先把第一第二个位置上的next标为-1,0，从第三位开始，观察模式串前部分和后部分相同的长度有多少(每次最多加1)，这么说可能比较抽象，举个栗子：| | | | | | | || — | — | — | — | — | — |–|| 模式串 | A | B | A | B | C | A || next[j]| -1| 0 | 0 | 1 | 2 | 0 | JS实现1234567891011121314151617function next(str) &#123; let next = [-1] let len = str.length let k = -1 let j = 0 while (j &lt; len - 1) &#123; if (k === -1 || str[j] === str[k]) &#123; k++ j++ next[j] = k &#125; else &#123; k = next[k] &#125; &#125; return next&#125;","categories":[{"name":"数据结构/算法","slug":"数据结构-算法","permalink":"http://lynnjs.com/categories/数据结构-算法/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://lynnjs.com/tags/KMP/"}]},{"title":"MpVue探坑日记","slug":"MpVue探坑日记","date":"2018-08-15T14:05:22.000Z","updated":"2019-09-27T10:03:18.428Z","comments":true,"path":"ck11ywqwi0005v8fyzunqhrk5/","link":"","permalink":"http://lynnjs.com/ck11ywqwi0005v8fyzunqhrk5/","excerpt":"","text":"MpVue 踩坑日记近日将原有的原生小程序迁移到 Vue 技术栈中，遂采用mpvue进行代码迁移和重构。建议将官方文档看一遍之后能避开大部分坑。 img 标签img 标签的 src 属性无法指向相对路径，需要用绝对路径代替。详见：GitHub tabbartabbar中的图标设置，需要将图片文件放在/static中才可以正常引用。详见：GitHub wx:指令转 v-指令v-for微信小程序的wx:for不需要指定 index，转到v-for之后需要指定 index。 dataset微信小程序的事件方法不能传参数，所以只能绑定在页面上，但是切换到 vue 就支持传参，因此可以去掉大部分的data:XXX绑定的语句。 bindtap 等事件事件的转换参考官方文档，大部分的移动端事件可以支持。 标签目前 view 标签迁移到 div 标签没有发现问题。 setData()小程序中 setData 有两种应用场景，一种是赋值，一种是把自己的值重新赋给自己用于更新页面。在 Vue 中由于采用了双向绑定，因此直接采用this.foo=bar即可 :key开发过程中遇到以下场景：通过 v-for 生成一系列自定义的组件，组件内部的 onload 方法里有一个语句会改变组件内部的值，现象是这个组件无限调用 onload 方法，导致调试器崩溃。经过排查，原来的 v-for 语句后边绑定的:key=&quot;Math.random(index)&quot;会出现问题，改为:key=&quot;index&quot;问题解决。使用 Math.random()绑定 key 值的原因在于，之前在练习 Vue 的时候，做了一个可添加删除的 TodoList，单纯地使用 inde 作为 key 值，在删除的时候出现了一个 bug，选中了 checkbox 的那一个条目删除之后，第二个条目的 index 值变成了前一个条目的 index 值，此时 vue 会认为这个 idnex 项可以复用，checkbox 的状态就被保留了，从此只使用两种方法进行 key 值的绑定： 1234:key=\"Date.now()+index\":key=\"Math.random(index)\"// 窃以为Vue的一大败笔就是默认复用，反而造成了某些项目的资源浪费// 核心方法UpdateChild()在以后的博客中会有涉及 具体为什么 Math.random()绑定 key 值造成无限刷新，还没有结果。 页面后退之后不销毁，数据缓存详见：#140解决方案：页面中添加生命周期 1234onUnload()&#123; Object.assign(this.$data, this.$options.data())&#125;// 不推荐全局注册，因为有些页面其实是需要缓存的，只有在某些特定页面比如包含input标签 Vue 文件内的 scoped style 标签发现一个问题：现象：在 vue 组件 ​​ 内部，带有 scoped 属性的 style 标签里，写 scss 嵌套样式，会出现第二层以上的样式失效。 ​成因：vue 的 scoped 有如 ​​ 下规则： 给 HTML 的 DOM 节点加一个不重复 data 属性(形如：data-v-2311c06a)来表示他的唯一性 在每句 css 选择器的末尾（编译后的生成的 css 语句）加一个当前组件的 data 属性选择器（如[data-v-2311c06a]）来私有化样式 如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的 data 属性 以上会导致嵌套的选择器附加的 data 属性选择器会错误网上找到的类似的情况有：https://blog.csdn.net/juse__we/article/details/80419617https://www.jianshu.com/p/f9a8b7784655https://github.com/vuejs/vue/issues/7067解决办法：养成好习惯，大段的嵌套样式在外部文件中，组件内 scoped 样式只写简单的非嵌套的样式 MpVue 中使用 SCSS使用官方的脚手架之后需要自行安装 node-sass 和sass-loader 更新时间：2018 年 08 月 15 日 22:26:32","categories":[{"name":"Coding","slug":"Coding","permalink":"http://lynnjs.com/categories/Coding/"}],"tags":[{"name":"Dev","slug":"Dev","permalink":"http://lynnjs.com/tags/Dev/"},{"name":"MpVue","slug":"MpVue","permalink":"http://lynnjs.com/tags/MpVue/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://lynnjs.com/tags/微信小程序/"}]},{"title":"工作心得#第肆周","slug":"工作心得-第肆周","date":"2018-08-05T03:28:26.000Z","updated":"2019-09-27T10:03:18.430Z","comments":true,"path":"ck11ywqxf0016v8fyf8u2ubhf/","link":"","permalink":"http://lynnjs.com/ck11ywqxf0016v8fyf8u2ubhf/","excerpt":"","text":"工作心得 #第四周正则表达式正则表达式在春天求职的时候就有学过，但是一直都没有扎实地记住。这周又重新仔细看了一遍 =&gt; 这篇文章，果然还是不能功利地学习啊…… 在学习的时候，我把正则表达式的元素分成两类，\b 字符类型和字符数量。字符类型分为匹配字符和匹配位置。字符数量分为 0,1,n 次。还有关于分组什么的单独学习吧。 Chrome Dev Tools用 JS 刷 LeetCode 的时候，debug 就全靠 Chrome Dev Tools 了，但是这个小工具其实还有很多隐藏功能。参考这篇文章。 Markdown 格式MarkDown GitBook localStorage/\bsessionStorage调试的时候在 Dev Tools 的 Application 选项卡中就可以找到。调用的时候用以下方法： 1234localStorage.setItem(\"Foo\", Bar)localStorage.getItem(\"Baz\")localStorage.clear()localStorage.removeItem(\"Qux\") escape()/encodeURI()/encodeURIComponent()区别见这里 判断 undefined/null/NaNThis KMP 算法async/await 实践","categories":[{"name":"Coding","slug":"Coding","permalink":"http://lynnjs.com/categories/Coding/"}],"tags":[{"name":"Dev","slug":"Dev","permalink":"http://lynnjs.com/tags/Dev/"}]},{"title":"读《构建之法：现代软件工程》 #2","slug":"读《构建之法：现代软件工程》-2","date":"2018-07-22T03:43:38.000Z","updated":"2019-09-27T10:03:18.433Z","comments":true,"path":"ck11ywqxz002dv8fybqvfbt2p/","link":"","permalink":"http://lynnjs.com/ck11ywqxz002dv8fybqvfbt2p/","excerpt":"","text":"《构建之法：现代软件工程》 #2Agree8.5 功能的定位和优先级这个老师上课的时候有详细讲过，关于“惊喜”“核心功能”和“基本功能”随投资力度和产品质量变化而增长的趋势。 12.1.1 用户体验的第一印象 5W1H 原则：Who、\bWhen、Where、What、Why、How 谁是你的目标用户？ 他们会在什么时候使用你的产品？ 目标用户会在哪里和你的产品交互？ 你的产品是什么？用户期待的是什么？ 用户为什么要使用你的产品？在众多的竞争产品中，用户为什么要选择你的产品？ 用户是如何与你的产品 \b 进行交互的？ 12.1.3 软件服务始终都要记得用户的选择描述了以下问题： 用户上了银行的门户网站，把语言改成英文，但是发来的手机验证码是中文的，而且在用户的手机上显示乱码。 12.2 用户体验设计的步骤和目标 需要指出的是，软件工程师往往以熟练掌握任职阻力大的工具而自豪(如命令行，Vim，EMACS 等)…… Notice8.6.3 提高估计能力的招数 Y=X±X÷N（对某件事情的估计时间 X，做过类似开发工作的次数 N） 9.4 领导力——搞笑的团队讨论 “对，而且……”“好，但是……” 图 9.7 创业公司失败的主要原因其中没有实际的市场需求占 42% 图 11.5 开发人员的标准开发流程12.3 用户体验评价标准 尽快提供可感触的反馈 系统界面符合用户的现实惯例 用户拥有控制权 一致性和标准化 适合各种类型的用户 帮助用户识别、诊断并修复错误 有必要的提示和帮助文档 Warning/QuestionFDD 的规范描述","categories":[{"name":"Notes","slug":"Notes","permalink":"http://lynnjs.com/categories/Notes/"}],"tags":[{"name":"Reading","slug":"Reading","permalink":"http://lynnjs.com/tags/Reading/"},{"name":"Software Engineering","slug":"Software-Engineering","permalink":"http://lynnjs.com/tags/Software-Engineering/"}]},{"title":"读《社会契约论》 #1","slug":"读《社会契约论》-1","date":"2018-07-20T13:39:45.000Z","updated":"2019-09-27T10:03:18.434Z","comments":true,"path":"ck11ywqxw0028v8fyce5kq38g/","link":"","permalink":"http://lynnjs.com/ck11ywqxw0028v8fyce5kq38g/","excerpt":"","text":"读《社会契约论》去年考研的时候才算是真真正正地学过一次哲学，但是仅仅从一个角度（马克思主义）来进行学习的。所以有关于哲学方面的问题仅做摘抄，不做深入讨论。 本书是由李平沤译、商务印书馆出版的，《社会契约论》——Amazon.cn。 网上还有何兆武版，有机会再读。 译者前言 卢梭的《社会契约论》探讨的是政治权力的原理，它的主旨是为人民民主主权的建立奠定理论基础。 “我把我的一生献给真理”——卢梭 第一卷 我不打算从阐明我所研究的问题的重要性论起，我要开门见山，一下笔就直接阐明主题。人们也许会问我是不是一位国君或立法者，因此才著书论述政治问题？我回答说：不是；而且，正是因为我这两者都不是，所以我才要谈论政治。如果我是国君或立法者，我就不会浪费时间谈论应当做些什么事了。该做些什么事，我会去做的，否则，我就什么话也不说。 第一章 第一卷的题旨 人生来是自由的，但却无处不身戴枷锁。自以为是其他一切的主人，反而比其他一切更是奴隶。 第二章 论原始社会 在所有各种各样的社会中，最古老而又唯一是自然形成的社会，是家庭。孩子只有在他们需要父亲养育他们的时候，才依附他们的父亲，而一旦没有这种需要了，他们之间的自然联系便宣告解体。孩子解除了他们对父亲应有的服从，而父亲也免除了他对孩子应有的关怀，双方都同样进人了独立状态。如果他们还继续联系在一起的话，那就不再是自然的，而是自愿的，这时，家庭本身便只有靠约定来维系。这种人人都有的自由，产生于人的天性。人的天性的首要法则是保护他自己的生存；他首先关心的，是照护好他自己。一当他到了有理智的年龄，那就只有他本人才能判断应当采用何种方法才最能维护他的存在。从这个时候起，他就成为他自己的主从以上的叙述来看，我们可以说家庭是政治社会的原始模型。政治社会的首领就好比一个家庭中的父亲，人民好比家中的子女；大家生来都是平等的和自由的，每个人都只有在对自己有利的时候才转让自己的自由 b 全部区别在于，在家庭中，父亲对子女的爱表现在他对子女的关心，从对子女的关心中得到乐趣；而在国家中，首领对人民没有这种父爱；他所关心的是如何统治人民，他以统治人民为乐。 卢梭早在 1755 年就批驳了有些学者认为专制政治和整个社会都是由父权派生出来的谬论。他说：“我们用不着去引用洛克和席德尼的相反的论点，只需指出这一点就够了：在世界上再也没有什么东西比父权的温柔与专制主义的暴虐更大相径庭了，因为父权的行使，给服从父权的人带来的好处，比行使父权的人得到的好处大得多。按照自然法，父亲只是在他的孩子需要他帮助的时候，他才是孩子的主人，过了这段期间，他们就是平等的，孩子便完全脱离父亲而独立·他们对于父亲只有尊敬的义务，而没有服从的义务，因为报答父母固然是一种应尽的义务，但不是一种可以强迫索取的权利。我们不仅不能说文明社会是由父权产生的，相反，我们应当说父权的主要力量来源于社会。”（卢梭：《论人与人之间不平等的起因和基础》，李平沤译，商务印书馆 2009 年版，第 106 一 107 页） 第三章 论最强者的权利 强力构不成权利，人们只是对合法的权威才有义务服从。 第四章 论奴隶制 放弃自己的自由，就是放弃自己做人的资格，就是放弃做人的权利，甚至就是放弃自己的义务。……这样一种既不等价又无交换的条件，难道不表明它本身是无效的吗？因为，既然我得奴隶所有的一切都属于我，既然他的权力就是我的权力，他还有什么权利反对我？ 可见战争绝对不是个人与个人的关系，而是国家与国家的关系。……如果未向某个国家的君主宣战便抢劫、杀害或关押该国的居民，那他就不是敌人，而是强盗。 因此战胜国有权处死那个国家的保卫者，只要他们手执武器抵抗。但是，一旦他们放下武器投降，不再当敌人或者敌人的工具了，他们便重新成为一般的人了，人们就没有权利伤害他们的生命。 有时候人们可以消灭一个国家的政权，但不消灭那个国家的任何一个成员。 第五章 论总需追溯到一个原始的约定 事实上，如果没有事先约定的话，除非选举的结果是全体致的，否则，少数人何以必须服从多数人的选择呢？那一百个选某人为首领的人凭什么权利替那十个不选那位首领的人投票呢？少数服从多数这个法则，其本身就是一种约定，表明至少有一次是全体一致的。 第六章 论社会公约 “创建一种能以全部共同的力量来维护和保庫每个结合者的人身和财产的结合形式，使每一个在这种结合形式下与全体相联合的人所服从的只不过是他本人，而且同以往一样的自由。”社会契约所要解决的，就是这个根本问题。 这样一来，如果我们把社会公约中非本质的东西都排除掉，社会公约就可简化成如下的词句：我们每一个人都把我们自身和我们的全部力量置于公意的最高指导之下，而且把共同体中的每个成员都接纳为全体不可分割的一部分。 第七章 论主权者第八章 论社会状态第九章 论财产权 现在让我用这样一句足以构成一切社会制度的基础的话来结束本章和本卷：“基本公约不仅没有摧毁自然的平等，反而以道德的和法律的平等来代替自然所造成人与人之间的身体上的不平等．，因而，虽然人与人之间在体力和智力上不相等，但由于公约和权利的保证，他们人人都是平等的。”","categories":[{"name":"Notes","slug":"Notes","permalink":"http://lynnjs.com/categories/Notes/"}],"tags":[{"name":"Reading","slug":"Reading","permalink":"http://lynnjs.com/tags/Reading/"},{"name":"哲学","slug":"哲学","permalink":"http://lynnjs.com/tags/哲学/"}]},{"title":"读《构建之法：现代软件工程》 #1","slug":"读《构建之法：现代软件工程》-1","date":"2018-07-15T10:56:31.000Z","updated":"2019-09-27T10:03:18.433Z","comments":true,"path":"ck11ywqxy002bv8fygxmizeen/","link":"","permalink":"http://lynnjs.com/ck11ywqxy002bv8fygxmizeen/","excerpt":"","text":"《构建之法——现代软件工程》 #1刚刚入职，想通过一本书快速地复习软件工程，来熟悉工作中的敏捷开发流程。或许能为团队在流程规范化上尽一份力。 在阅读的时候随时在书上做标记，分别有以下含义： Agree Notice Warning/Question Disagree 计划用四周时间完成阅读和笔记。 Agree1.2.3 软件工程的知识领域 P14没有银弹： “不会有任何单一软件工程上的突破，能够让程序开发的生产力得到一个数量级的提升。” 霍夫斯塔特定律： “实际时间总是比预期的要长，即便你考虑了霍夫斯塔特定律。” “向进度落后的项目中增加人员，会让项目更加落后。” 3.1 个人能力的衡量与发展 P47 软件工程师不能按时交付的原因，是他们有时候不满足于“解决目前直接的问题”，而是想“解决问题背后的问题”，或者是“解决通用的、不直接的，但有重大意义的问题”。 十分认同。常常有以下两种情景存在： 实现时注意到之前解决方案不够“完美”（如样式） 实现方法和以往实现思路有冲突或可完善（如提取出函数） 4.5.3 不间断地复审 P80 “每个人每天的高效率工作时段不超过3-4个小时” 认同。对于我来说，每天上午10-11点，下午2-5点思路最清\b晰，甚至每天都感觉不到这个时间段的存在。沉浸式的编码虽然享受，但是非常消耗精力，五点钟过后整个大脑都无法有条理的思考。（也许是饿的） 4.6.2 如何正确地给予反馈 P85 图 4-2 评论别人的三种层次 最外层：行为和后果“你迟到了，让我很着。我们错过了表演！” 中间层：习惯和动机“你怎么又放我鸽子，你总是不重视我！” 最内层：本质和固有属性“你太自私了，你们XXX村的男人没一个好东西！” 认同。 从小到大这种人真的太多了，说白了就是“上纲上线”，你不顺我心了，好你就是自私，你全家都自私。第三层涉及到人的本质属性，比如自私、地域等，对这个方面进行攻击连解释的机会都没有。 Notice2.4 实践——设计有实际意义的软件工程作业 P37SRP,DCP SRP(Single Responsibility Principle)单一职责原则指出： “一个模块（类）应该只有一个导致它变化的原因，一个模块应该完全对某个功能负责。” OCP(Open-Close Principle)开放-封闭原则： “软件实体应该是可扩展的，同时是不可修改的。” 这两个原则过于“理想”。事实上经常需要模块对于新需求来进行更改。例如封装好的图表或者组件库，如果想单纯地在组件上添加新需求，就需要修改组件内的编码。 个人认为SRP和OCP只能在小型模块中实现，而在大型系统中这么做就难免陷入到被细碎的小模块淹没的情况。 Warning/Question案例2——P59问题描述： 程序员小飞原计划三天完成某个任务，他说服了同事，坚持采用自己独特的实现方法。现在是第三天下午，它马上就可以做完，但是在实现的过程中他越来越意识到自己原来设计中\b的弱点，他应该采取另一个办法，才能避免后面集成阶段的额外任务。但是如果现在就改弦更张，那就意味着公开承认自己的设计不好，并且会花费额外的时间。如果他按部就班地完成，最后整个团队还要花更多的时间在集成上，但那就不是他个人的问题了。怎么办？ 如果是我可能会加班改方案吧……但是一定要跟人确定改之后的是可行的。 Disagree4.3.2 代码设计规范-goto P69文中写到： 函数最好有单一的出口，为了达到这一目的，可以使用goto。 一般不推荐使用goto函数，goto并不能让逻辑清晰，反而会掩盖逻辑。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://lynnjs.com/categories/Notes/"}],"tags":[{"name":"Reading","slug":"Reading","permalink":"http://lynnjs.com/tags/Reading/"},{"name":"Software Engineering","slug":"Software-Engineering","permalink":"http://lynnjs.com/tags/Software-Engineering/"}]},{"title":"工作心得#第贰周","slug":"工作心得-第贰周","date":"2018-07-15T10:43:11.000Z","updated":"2019-09-27T10:03:18.430Z","comments":true,"path":"ck11ywqxh0018v8fynu80j1va/","link":"","permalink":"http://lynnjs.com/ck11ywqxh0018v8fynu80j1va/","excerpt":"","text":"箭头函数的使用箭头函数和 function 命名的函数区别主要在于 this 的指向。function 函数的 this 值和执行环境有关，箭头函数的 this 值在定义时就确定。如下图 downloadJson 和 themeJson 都取不到，会报错。 12345678910111213141516171819202122232425data()&#123; return &#123; this.downloadJson, this.themeJson &#125;&#125;methods:&#123; let option =&#123; title: [&#123; subtext: '总计 ' + Object.keys(this.downloadJson).reduce(function (all, key) &#123; return all + this.downloadJson[key]; &#125;, 0), x: '75%', textAlign: 'center' &#125;, &#123; text: '主题下载', subtext: '总计 ' + Object.keys(this.themeJson).reduce(function (all, key) &#123; return all + this.themeJson[key]; &#125;, 0), x: '75%', y: '50%', textAlign: 'center' &#125;], &#125;&#125; map()/reduce()具体可以看以下博客 map/reduce 廖雪峰的博客 map/reduce MDN Docs 简单来说 map()方法就是依次将数组内所有值执行一个过程（函数），返回值仍然是数组，比如每个元素加 1。 reduce()方法就是讲所有的元素执行一个过程后返回一个值比如求和。 123// 不用parseInt和Number转数字var string2int = s=&gt;s.split(\"\").map(x=&gt;+x).reduce((x,y)=&gt;(x*10+y)) veitical-align这个地方感觉坑很多，这周的工作中由于用到了很多 inline 的横向布局，在文字和图片混排的过程中 vertival-align 的变动很大。还没有研究明白，日后再填坑。 参考链接:vertical-align","categories":[{"name":"Coding","slug":"Coding","permalink":"http://lynnjs.com/categories/Coding/"}],"tags":[{"name":"Dev","slug":"Dev","permalink":"http://lynnjs.com/tags/Dev/"}]},{"title":"网易游戏电话面试","slug":"网易游戏电话面试","date":"2018-03-27T22:56:20.000Z","updated":"2019-09-27T10:03:18.432Z","comments":true,"path":"ck11ywqxs001xv8fyoef7cej2/","link":"","permalink":"http://lynnjs.com/ck11ywqxs001xv8fyoef7cej2/","excerpt":"","text":"网易游戏投递了两个职位：游戏研发和游戏策划。 3.19日 HR来电话约在27日下午两点进行电话面试3.27日 准时来电 问题 自我介绍，主要介绍自己的项目经历 那你对JS比较熟还是C++比较熟 JS 说一下JS的内存管理吧 JS没接触过内存管理，我说一下C++吧……然后说了一通malloc/free/new/delete/new[]/delete[]的区别 你对图形学有了解吗 没有 基础方面的比如数据结构应该有学过吧 有的 说一下数组和链表的区别 数据结构/随机访问/碎片 简单说一下红黑树 特征，应用，与AVL的区别 计算机网络有学过吗，说一下cookie和session的区别 生存周期，存储位置等 HTTP和HTTPS有什么区别 安全性 openSSL的加密算法能讲一下吗没了解过 操作系统有学过吧，讲一下什么是“粘程（没听清）”没听过…… 下面考你一个算法题，赛马问题有了解过吗，有25匹马，5条赛道，最快可以进行多少次比赛找出前三快的马？很尴尬没答出来……我还以为会问一个动态规划之类的或者树/图算法……就说了个暴力方法…… 能接受来杭州工作吧能 心目中预计的薪酬大概是在什么位置1W以上吧 你有什么问题吗 网易游戏大概有多少工作室？ 网易游戏下边有十几个事业群，每个事业群下又有好多工作室，所以具体的数目…… 这些工作室都是做手游的吧？ 没错，端游也有，但是网易目前没有开发端游的计划 如果这次面试没过我应该会参加第二志愿的第二批面试对吧？ 这个不太清楚 面试结果要多久通知呢？ 七个工作日内 3.29日15：36接到同一HR电话，通知4月4日去杭州二面。","categories":[{"name":"求职","slug":"求职","permalink":"http://lynnjs.com/categories/求职/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lynnjs.com/tags/面试/"}]},{"title":"网易教育前端电话面试","slug":"网易教育前端电话面试","date":"2018-03-22T09:53:10.000Z","updated":"2019-09-27T10:03:18.432Z","comments":true,"path":"ck11ywqxp001qv8fyjdxqhfud/","link":"","permalink":"http://lynnjs.com/ck11ywqxp001qv8fyjdxqhfud/","excerpt":"","text":"时间 3.15–网易社会招聘页面发布校招专版，投递了包含网易教育在内的三个前端岗位。 3.19 17:48–网易教育前端HR打来电话，想要立即面试，我定在了3.21日下午。 3.21 10:45–HR打来电话进行面试，到10:59，HR说突然有事下午再打来。然而下午并没有打来电话。 3.22 10:41–HR打来电话，继续昨天的问题。 问题 先做个自我介绍吧 姓名学校专业，经历，优点，大概说一下项目，两分钟左右 你是没有实习经历的吧，我看你简历上没有写 有的，应该在实习经历那一栏里 那说一说你这个实习实际都做了什么 实习项目，重点说成果和做了什么 讲一讲你简历上的这两个项目 突出技术栈和成果 这两个项目中哪个你比较满意 WiFi探针 这个项目的核心技术是什么 ！@￥%@#%！ 抱歉打断你一下，我这边突然有点事情要处理，下午再打给你好吗？实在是对不起 好 接着昨天的问题说，那我们来聊一聊技术方面的问题，讲一讲CSS的BOX-Model 从外到内margin-&gt;border-&gt;padding-&gt;content 如何让width属性包含margin的宽度？ 不了解 CSS的display属性有了解过吗 block inline inline-block none分别讲效果和区别 说一下position的几个属性 absolute relative （这里懵住了，忘了一个fixed） 说一下DOM的结构 DOM BOM的结构，从window开始到document和下边的树形结构 JS的跨域有了解过吗？如何解决的？ 不同域名或者端口下的沟通，大概说了三个方法 JSONP window . name window.postMessage + localStorage 你在实际应用中有遇到过跨域问题吗 讲了一下发现的单独打开HTML文件和nodejs环境下打开URL的问题 了解过JS原型链吗，简单讲一下 红宝书有详细的介绍，讲了三种继承方式，组合继承，原型继承，寄生组合继承 那如果新建一个student类怎么继承这个person类 原型式继承，Object.creat() JS的事件机制是怎么样的 事件委托的方法 事件冒泡和事件捕获的原理 如何阻止这个事件冒泡 stopPropagation(这里我有点急了，因为这个问题我太熟悉了，当时调了很久的bug，没等他说完我就开口了) 我看你的项目都有用到jQuery，那你说说如何用jQuery操作三个div的顺序 jQuery选择器的基础知识，但是插入到div前边的方法我给忘了 网易教育这边用的vue.js和react.js你有了解过吗 没有 网易教育公司在杭州，你能接受来杭州工作吧 可以 你对网易这边有什么问题吗 您面试的是网易教育的前端吧，那网易教育这边团队配置是怎么样的呢，\b比如人员组成 300多人的公司 1/3搞技术，其中1/4前端 网易教育是在网易本部还是单独的办公楼？ 在网易本部 后续有消息会通知你，再见 HR人很好，语气没有丝毫的攻击性，就是有的时候话筒不太清晰，听不清术语。两天加起来持续了大概50分钟，聊的我口干舌燥，好在项目经历够多。 还有我被鸽了很难受。 准备美团的笔试。 UPDATE:次日收到拒信。","categories":[{"name":"求职","slug":"求职","permalink":"http://lynnjs.com/categories/求职/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://lynnjs.com/tags/面试/"}]},{"title":"考研","slug":"考研","date":"2018-01-06T12:27:09.000Z","updated":"2019-09-27T10:03:18.432Z","comments":true,"path":"ck11ywqxv0025v8fyu24yb71l/","link":"","permalink":"http://lynnjs.com/ck11ywqxv0025v8fyu24yb71l/","excerpt":"","text":"去年的寒假下定决心要考研，当时的考虑是，1，对自己工作方向的重定位。从大二开始就只做过前端或者说是web的开发，虽然说靠着前端的技术混口饭吃并不难，但是前端的人才呈现井喷式增长。一方面得益于JavaScript的简单易学，另一方面是各大培训机构大四宣传前端的“高薪”或者“轻松”，大量的培训机构生产线产出前端人员，导致前端市场人才参差不齐，给人一种搞前端是很简单甚至不入流的工作的感觉。在这样的考虑之下，想要变更自己的工作方向，考研是最便捷的一种做法。研究生阶段可以有充足的时间来熟悉当前热门的机器学习。（虽然说机器学习也有些乌烟瘴气）2，如果以后想留在北京发展，户口问题是一个不可回避的问题。 时间规划因为对自己的数学不自信，暑假之前一直在复习高数。暑假期间结束了政治和数学的基础和强化课程。暑假结束后的学期集中进行刷题和模拟训练。 暑假在家里待了一周，7月20日回到学校开始进行复习。暑期大块时间比较多，所以我用来过了一遍政治和数学刷题。 9月底预报名就报名成功了，没有再修改。随后开始每天去图书馆自习。 10月份巩固基础，11，12集中刷套题。 图书馆的五楼是环境最好的，有单独的小桌子，每个人中间还有挡板隔着，学习效果很好；但是五楼也很抢手，十月一一过，五楼就根本抢不到了，所以我每天6点半起床，洗漱，吃早饭，七点三十可以到图书馆门口排队，每天都坐在同一个位置上。 考前去看了考场。 结果考完之后就觉得自己的数学不是很理想。1月份彻底放弃了希望。查分之后并没有很强烈的失落感，可能是这种日子太久终于解脱了。3月份又觉得有点希望，开始联系老师并准备复试。 过了校线，但是今年的政策有变。往年的考研是，够学硕就面学硕，够专硕面专硕。但是今年报了学硕的人要先够学硕的分数才可以面专硕。我刚好处于这个很尴尬的地位。 感想累。后悔。我觉得目前为止的20多年里我做的最没用的事就是考研。 如果非要说出好处，一是接触到了马克思主义哲学，二是提前为求职面试复习了计算机。 准备网易游戏面试。","categories":[{"name":"人生","slug":"人生","permalink":"http://lynnjs.com/categories/人生/"}],"tags":[{"name":"考研","slug":"考研","permalink":"http://lynnjs.com/tags/考研/"}]},{"title":"软件工程实践之结语","slug":"软件工程实践之结语","date":"2017-07-06T13:00:45.000Z","updated":"2019-09-27T10:03:18.434Z","comments":true,"path":"ck11ywqy0002ev8fyeqeaadh8/","link":"","permalink":"http://lynnjs.com/ck11ywqy0002ev8fyeqeaadh8/","excerpt":"","text":"为期十天的软件工程实践课也就是小学期已经结束了。从6月26日到7月5日，同学们自发组成团队，在实验室集中开发，完成老师提供的需求文档的要求。期间要求一次发布，两次迭代，并进行统一展示答辩，发布后提供各种说明文档若干。这期间虽然累，但是收获很多，整理成报告如下。 Scrum用户故事用户故事是指在软件开发和项目管理中用日常语言或商务用语写成的句子。这个句子反应终端用户或系统用户捕捉到的关于一个用户在其工作职责的范围内做的或需要做的事务。 用户故事的划分和估算点数、优先级的选取至关重要，关系到一次迭代、发布、甚至是整个项目的顺利进行。在课程中观察到，出现在各组的问题主要是粒度过大。 在估算点数问题上，我们小组的方法是，选一个基础用户故事的实际时间为标准时间，其他用户故事的估算实际时间与其比值为估算点数。 Scrum主要角色小组的组成人员为：一位Scrum Master，一位Business Analysis，若干名DEV人员。 Scrum Master是Scrum团队带头人，保证团队正常运作，并且帮助队员排除障碍，维护日常各种图表等。 BA的职责是确定产品的方向和愿景，负责和用户沟通，明确用户故事，定义产品发布的内容，优先级交付的时间，对产品的投入回报比负责。 开发团队，是一个跨职能的小团队，团队必须拥有交付软件需要的各种技能。 迭代在每一次迭代中（本项目为5天），开发团队创建可用的软件的一个增量。将用户需求按照优先级划分，在迭代计划会议中，BA告知开发团队需要完成的用户故事。在迭代的过程中，没有人能够变更迭代订单，这意味着在一个迭代中需求是被冻结的。 图表维护在本次实践中，需要维护的图表主要有：燃尽图，情绪图和看板 燃尽图虽然没有呈现直线，但是始终保持在标准线附近，说明开发人员一直在全力开发。在第一次迭代的时候出现过一次在标准线下的点，但是第二次迭代普遍比标准线高，原因在于第二次迭代的时候发现一些功能并没有完全地实现，完善仍然需要很多时间，耽误了现有的进度。 情绪图表现了整个团队的情绪情况，在实际开发中，有时候影响开发效率的并不是技术问题，而是情绪问题，这时候就需要SM和BA来一起协调队员们的情绪，保证开发正常进行。 看板在每次早晨的站会和下班之前进行更新，确定今天的计划和完成情况。 Web技术理想中的架构 架构图 前端用node.js提供的模板（EJS/JADE）等可以非常方便地写出各种动态页面，避免了前端人员接触JSP等带有JAVA的代码。前端从node.js通过AJAX获取数据，node.js向Tomcat发送http请求获取数据，运算等均在后端进行。前后端用统一数据格式JSON交流，不同URL对应不同的数据。 这样的架构优点是： 前端人员完全回避了不会JAVA代码的尴尬，用熟悉的JavaScript配置web服务器。其次前端人员可以使用更多的模板和CSS预加载工具，例如模板工具EJS/JADE，CSS预处理工具Stylus/Sass/LESS。 后端人员不用再将HTML改成JSP，数据对接上只需要将数据封装成JSON，然后写好每个URL对应的路由即可。 Node.js为I/O密集型Web服务器，Tomcat+SpringMVC可以面对大部分CPU密集型情景，因此该架构可以承受很大的访问量和数据计算量。淘宝各大促销活动用的架构均基于该架构开发。 缺点是：大大增加了前端人员的工作量，对前端人员要求很高。Node.js服务器算不上极其稳定，相比于JAVA的Web服务器来说，不稳定性提高。 实际中采用的架构 架构图 安排一个开发人员将HTML代码改成JSP。 这样做的优点为，后端人员对于JSP代码很熟悉，充分了解逻辑，便于后端人员的开发。前端人员专注写页面的样式。 缺点：前端有时需要AJAX，有时需要JSP来数据对接，经常发生有的数据通过两种方法对接，或者两种方法都没有用过而自己为是对方的任务。前端对于整个页面的把握大大下降。 关于团队关系结对编程在开发过程中，逐渐意识到，对于一个技术不太熟练的人，花时间教他技术要比花时间自己开发的效率要高的多。这个时候结对编程就体现出来很重要的意义。 出现BUG之后，结对编程也起着很重要的作用，代码书写者逐行地解释代码的含义和作用，这种方法很快就能将BUG落实到具体的部分。而这种过程如果独自来实现会需要很长时间。 情绪控制开发过程中始终要意识到自己身处在一个团队中，自己的情绪可能会影响其他人，而情绪又是影响开发效率的一个很关键的因素，因此不要因为一些小事就在工作中发脾气，这样会影响整个团队的开发效率。 总结RUA!","categories":[{"name":"Team","slug":"Team","permalink":"http://lynnjs.com/categories/Team/"}],"tags":[{"name":"Dev","slug":"Dev","permalink":"http://lynnjs.com/tags/Dev/"}]},{"title":"软件工程实践之第一次迭代","slug":"软件工程实践之第一次迭代","date":"2017-06-29T07:02:36.000Z","updated":"2019-09-27T10:03:18.434Z","comments":false,"path":"ck11ywqy3002lv8fy3b8yn8qu/","link":"","permalink":"http://lynnjs.com/ck11ywqy3002lv8fy3b8yn8qu/","excerpt":"","text":"软件工程实践小学期要求大家自行组队，运用\b敏捷开发，满足老师的用户需求。 截至目前开发了五天，前一天半为需求分析。写下这段文字的时候正在进行分组展示。 心得如下 关于jQuery\b中的点击事件在本次的开发中，有一个应用场景。需要在点击&lt;button&gt;后，在&lt;ul&gt;内添加一个&lt;li&gt;，在这个&lt;li&gt;中会有一定的class。 按照以往的习惯，在index.js里面预先写好class的点击事件 123$('.class').click(function()&#123; console.log();&#125;) 实际开发的时候发现click事件无法在“预先写在.js里，后插入html的片段”触发。 经查阅，有以下解决办法。 在jQuery1.9-版本，可以使用123$('.class').live(function()&#123; console.log();&#125;) 在jQuery1.9+版本，可以使用123$('.parentclass').on('click','.class',function()&#123; console.log()；&#125;) 关于Materialize框架首先是在hexo博客模板里面发现了Material-UI，进而了解到Material Design。不得不说谷歌的卡片化+彩色混搭风格格外的好看。 Material-UI基于react.js开发，对于react.js并不是很了解。 material for bootstrap是基于bootstrap开发的material design风格的前端模板。但是由于优化并不是很好，导致整篇都是bootstrap的lowlow的风格…… 最后选择了Materialize. 关于团队在本次开发中发现的问题可以概括为，责任心。 已隐藏","categories":[{"name":"Team","slug":"Team","permalink":"http://lynnjs.com/categories/Team/"}],"tags":[{"name":"Dev","slug":"Dev","permalink":"http://lynnjs.com/tags/Dev/"}]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2017-06-05T01:30:23.000Z","updated":"2019-09-27T10:03:18.427Z","comments":true,"path":"ck11ywqwb0001v8fypc5ewl18/","link":"","permalink":"http://lynnjs.com/ck11ywqwb0001v8fypc5ewl18/","excerpt":"\b5月份尝试过用node.js+express+mongodb搭建博客，参考了这篇文章NodeJS和Express搭建多人博客。实现了注册、登录、发布功能，用了ejs渲染。结果mongodb的各种中间件过于复杂，前端很难写。 目前主流的个人博客框架有jekyII和Hexo两款比较流行。","text":"\b5月份尝试过用node.js+express+mongodb搭建博客，参考了这篇文章NodeJS和Express搭建多人博客。实现了注册、登录、发布功能，用了ejs渲染。结果mongodb的各种中间件过于复杂，前端很难写。 目前主流的个人博客框架有jekyII和Hexo两款比较流行。 jekyII和Hexo都支持markdown语法，其中jekyII基于Ruby，Hexo基于Node.js。鉴于Node.js经验比较丰富，npm等命令比较熟悉，选择了Hexo。 准备工作 BandwagonHost VPS一台，Ubuntu16.04 Node.js v7.7.1 (本地和服务 器) GitHub 私有库 Nodejs服务器配置参考以下两篇文章 CentOS Ubuntu Hexo安装Hexo 1npm install hexo-cli -g 初始化项目 1hexo init [folder] 安装主题 Next 新建文章 1hexo new [layout] [title] GitHubGitHub网页上新建库，然后本地以下命令 1234git initgit add .git remote origin &lt;ssh&gt;git push origin master GitHub上作为博客备份 服务器端配置安装Nginx 12apt-get install nginxnginx -v 修改Nginx配置 远程部署这里选用rsync方法进行部署 服务端 1apt-get install rsync 本地 1npm install hexo-deployer-rsync --save 本地配置 _config.yml 123456deploy: type: rsync host: ip user: root root: /var/www/html port: 22 免密码部署可以发现如果用root进行ssh部署，每次都需要输入密码。而且bandwagon每次提供的ssh密码均为随机密码，很难输入。这里思路是在vps里新建用户，然后再该用户目录里面部署blog。将本地的公钥存储在authorized_key里面，以后进行ssh连接可以进行免密码。同时新建用户的权限比较低，所以整体系统也比较安全。参考以下文章：CSDN BURKEXU’BLOG 至此，新建文档后，通过 1hexo g -d 实现一键部署。","categories":[{"name":"Coding","slug":"Coding","permalink":"http://lynnjs.com/categories/Coding/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://lynnjs.com/tags/blog/"},{"name":"node","slug":"node","permalink":"http://lynnjs.com/tags/node/"},{"name":"服务器","slug":"服务器","permalink":"http://lynnjs.com/tags/服务器/"}]}]}