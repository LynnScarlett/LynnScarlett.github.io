<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>用代码做画笔</title>
  
  <subtitle>童言无忌</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lynnjs.com/"/>
  <updated>2019-09-27T10:03:18.428Z</updated>
  <id>http://lynnjs.com/</id>
  
  <author>
    <name>朱童</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode Contest 128</title>
    <link href="http://lynnjs.com/ck11ywqwg0004v8fyxe42g9gx/"/>
    <id>http://lynnjs.com/ck11ywqwg0004v8fyxe42g9gx/</id>
    <published>2019-03-20T01:18:54.000Z</published>
    <updated>2019-09-27T10:03:18.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Contest-128"><a href="#LeetCode-Contest-128" class="headerlink" title="LeetCode Contest 128"></a>LeetCode Contest 128</h1><p>LynnScarlett<br>Rank: 1307 / 5165<br>Finish Time: 0:14:32<br>Score: 6</p><h2 id="1012-Complement-of-Base-10-Integer"><a href="#1012-Complement-of-Base-10-Integer" class="headerlink" title="1012. Complement of Base 10 Integer"></a>1012. Complement of Base 10 Integer</h2><p><a href="https://leetcode.com/problems/complement-of-base-10-integer/" target="_blank" rel="noopener">1012. Complement of Base 10 Integer</a></p><p>翻译：非负数 N，表示成二进制形式后取反，返回该十进制表示。</p><p>思路：用最接近 N 的 2 的 i 次幂-1，减 N。如：<code>101 = 111 - 010</code></p><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; N</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> bitwiseComplement = <span class="function"><span class="keyword">function</span>(<span class="params">N</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (N &gt; <span class="number">2</span> ** i - <span class="number">1</span>) &#123;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> ** i - <span class="number">1</span> - N</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1013-Pairs-of-Songs-With-Total-Durations-Divisible-by-60"><a href="#1013-Pairs-of-Songs-With-Total-Durations-Divisible-by-60" class="headerlink" title="1013. Pairs of Songs With Total Durations Divisible by 60"></a>1013. Pairs of Songs With Total Durations Divisible by 60</h2><p><a href="https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/" target="_blank" rel="noopener">1013. Pairs of Songs With Total Durations Divisible by 60</a></p><p>翻译：一个数组中求两个元素相加能被 60 整除的数量。</p><p>思路：暴力遍历</p><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; time</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numPairsDivisibleBy60 = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; time.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; time.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === j) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((time[i] + time[j]) % <span class="number">60</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        res++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1014-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1014-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1014. Capacity To Ship Packages Within D Days"></a>1014. Capacity To Ship Packages Within D Days</h2><p><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1014. Capacity To Ship Packages Within D Days</a></p><p>翻译： 有一个货物重量数组，要求在 D 天内运送完毕，从传送带一侧到另一侧需要用一天时间，求传送带最少需要支撑的重量</p><p>思路：遍历，从最大的货物重量，到货物总重量，进行二分查找</p><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; weights</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; D</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> shipWithinDays = <span class="function"><span class="keyword">function</span>(<span class="params">weights, D</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = weights.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Math</span>.max(...weights)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> day = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (total + weights[i] &lt;= mid) &#123;</span><br><span class="line">        total += weights[i]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        i--</span><br><span class="line">        day++</span><br><span class="line">        <span class="keyword">if</span> (day &gt; D) &#123;</span><br><span class="line">          <span class="keyword">if</span> (start === end) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">          <span class="keyword">return</span> binarySearch(mid + <span class="number">1</span>, end)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start === end) <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">return</span> binarySearch(start, mid)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> binarySearch(min, max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1015-Numbers-With-Repeated-Digits"><a href="#1015-Numbers-With-Repeated-Digits" class="headerlink" title="1015. Numbers With Repeated Digits"></a>1015. Numbers With Repeated Digits</h2><p><a href="https://leetcode.com/problems/numbers-with-repeated-digits/" target="_blank" rel="noopener">1015. Numbers With Repeated Digits</a></p><p>翻译：求不大于 N 的正整数中，含有相同数字的数的个数</p><p>思路：</p><ol><li>遍历（超时）</li><li>排列组合，详见：<a href="https://leetcode.com/problems/numbers-with-repeated-digits/discuss/257281/Java-O%281%29-0ms-beats-all" target="_blank" rel="noopener">discuss</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode-Contest-128&quot;&gt;&lt;a href=&quot;#LeetCode-Contest-128&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Contest 128&quot;&gt;&lt;/a&gt;LeetCode Contest 128&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://lynnjs.com/categories/Algorithm/"/>
    
    
      <category term="LeetCode" scheme="http://lynnjs.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>一些手写代码题（前端）</title>
    <link href="http://lynnjs.com/ck11ywqwj0006v8fyn9bzp7o6/"/>
    <id>http://lynnjs.com/ck11ywqwj0006v8fyn9bzp7o6/</id>
    <published>2019-03-19T09:19:34.000Z</published>
    <updated>2019-09-27T10:03:18.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些手写代码题"><a href="#一些手写代码题" class="headerlink" title="一些手写代码题"></a>一些手写代码题</h1><p>春天找工作，遇到了许多手写代码的场景，从基本数据结构（链表，二叉树），到实际应用的场景（闭包，并发），都有涉及。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="实现一个-repeat-函数"><a href="#实现一个-repeat-函数" class="headerlink" title="实现一个 repeat 函数"></a>实现一个 repeat 函数</h3><p>问题描述：实现一个 repeat(fn, times, interval) 函数，使得</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = repeat(<span class="built_in">console</span>.log, <span class="number">5</span>, <span class="number">500</span>)</span><br><span class="line">s(<span class="string">"message"</span>)</span><br><span class="line"><span class="comment">// 输出 'message' 间隔0.5s</span></span><br></pre></td></tr></table></figure><p>思路：</p><ol><li>要注意多参数情况；</li><li>当 fn 耗时大于间隔时，下一次 fn 执行需要等待足够的 interval；</li><li>注意闭包函数实现时，不要修改内部的 times 和 interval。</li></ol><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">fn, times, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> localTimes = times</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        localTimes--</span><br><span class="line">        fn(...args)</span><br><span class="line">        <span class="keyword">if</span> (localTimes) &#123;</span><br><span class="line">          timeout()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, interval)</span><br><span class="line">    &#125;</span><br><span class="line">    timeout()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个-并发控制-函数"><a href="#实现一个-并发控制-函数" class="headerlink" title="实现一个 并发控制 函数"></a>实现一个 并发控制 函数</h3><p>问题描述： 实现一个函数 <code>request(urls, max, callback)</code>，实现发送 urls 数组里的请求，最大并发数为 max，所有请求结束后，调用 callback。</p><p>思路：首先看到所有请求结束之后的调用，首先想到的是<code>Promise.all</code>方法，但是这样实现并发比较困难。这里想的是</p><ol><li>发送 max 个请求；</li><li>每个请求结束之后发起下一个请求；</li><li>当 urls 数组里没有待发请求的时候，调用 callback。</li></ol><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">urls, max, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> localUrls = urls.slice()</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> req = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch(localUrls.shift()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (localUrls.length) &#123;</span><br><span class="line">        req()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        called = <span class="literal">true</span></span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    req()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树路径"><a href="#二叉树路径" class="headerlink" title="二叉树路径"></a>二叉树路径</h3><p>问题描述： </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一些手写代码题&quot;&gt;&lt;a href=&quot;#一些手写代码题&quot; class=&quot;headerlink&quot; title=&quot;一些手写代码题&quot;&gt;&lt;/a&gt;一些手写代码题&lt;/h1&gt;&lt;p&gt;春天找工作，遇到了许多手写代码的场景，从基本数据结构（链表，二叉树），到实际应用的场景（闭包，并发）
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://lynnjs.com/categories/JavaScript/"/>
    
      <category term="求职" scheme="http://lynnjs.com/categories/JavaScript/%E6%B1%82%E8%81%8C/"/>
    
    
      <category term="面试" scheme="http://lynnjs.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式问题记录</title>
    <link href="http://lynnjs.com/ck11ywqxm001jv8fya2ioxl3r/"/>
    <id>http://lynnjs.com/ck11ywqxm001jv8fya2ioxl3r/</id>
    <published>2019-03-14T13:28:10.000Z</published>
    <updated>2019-09-27T10:03:18.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式问题记录"><a href="#正则表达式问题记录" class="headerlink" title="正则表达式问题记录"></a>正则表达式问题记录</h1><h2 id="Q1-为什么正则表达式-第一次为-true，第二次为-false"><a href="#Q1-为什么正则表达式-第一次为-true，第二次为-false" class="headerlink" title="Q1: 为什么正则表达式 第一次为 true，第二次为 false"></a>Q1: 为什么正则表达式 第一次为 true，第二次为 false</h2><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/gi</span>)</span><br><span class="line">reg.test(<span class="string">"abc "</span>) <span class="comment">// true</span></span><br><span class="line">reg.test(<span class="string">"abc "</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个问题的产生原因是：当有全局匹配标记时，每个正则表达式都有 lastIndex 属性，记录下一次匹配的位置，匹配过一次之后 lastIndex 没有归零。</p><p>以下是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex" target="_blank" rel="noopener">MDN</a>对于 lastIndex 的解释：</p><blockquote><p>只有正则表达式使用了表示全局检索的 “g” 标志时，该属性才会起作用。此时应用下面的规则：</p><ul><li>如果 lastIndex 大于字符串的长度，则 regexp.test 和 regexp.exec 将会匹配失败，然后 lastIndex 被设置为 0。</li><li>如果 lastIndex 等于字符串的长度，且该正则表达式匹配空字符串，则该正则表达式匹配从 lastIndex 开始的字符串。（then the regular expression matches input starting at lastIndex.）</li><li>如果 lastIndex 等于字符串的长度，且该正则表达式不匹配空字符串 ，则该正则表达式不匹配字符串，lastIndex 被设置为 0.。</li><li>否则，lastIndex 被设置为紧随最近一次成功匹配的下一个位置。</li></ul></blockquote><p>解决办法：</p><ol><li>去掉<code>g</code>标志;</li><li>在每次匹配之后将<code>reg</code>的<code>lastIndex</code>置 0。</li></ol><p><em>此文不定期更新，用于记录</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式问题记录&quot;&gt;&lt;a href=&quot;#正则表达式问题记录&quot; class=&quot;headerlink&quot; title=&quot;正则表达式问题记录&quot;&gt;&lt;/a&gt;正则表达式问题记录&lt;/h1&gt;&lt;h2 id=&quot;Q1-为什么正则表达式-第一次为-true，第二次为-false&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://lynnjs.com/categories/JavaScript/"/>
    
    
      <category term="Tips" scheme="http://lynnjs.com/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Contest 127</title>
    <link href="http://lynnjs.com/ck11ywqw50000v8fyehcs8cbp/"/>
    <id>http://lynnjs.com/ck11ywqw50000v8fyehcs8cbp/</id>
    <published>2019-03-11T00:59:31.000Z</published>
    <updated>2019-09-27T10:03:18.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Contest-127"><a href="#LeetCode-Contest-127" class="headerlink" title="LeetCode Contest 127"></a>LeetCode Contest 127</h1><p>从上周开始参加 LeetCode Contest。</p><p>LynnScarlett<br>Rank: 1806 / 4734<br>Finish Time: 1:29:22<br>Score: 13</p><h2 id="1005-Maximize-Sum-Of-Array-After-K-Negations"><a href="#1005-Maximize-Sum-Of-Array-After-K-Negations" class="headerlink" title="1005. Maximize Sum Of Array After K Negations"></a>1005. Maximize Sum Of Array After K Negations</h2><p><a href="https://leetcode.com/contest/weekly-contest-127/problems/maximize-sum-of-array-after-k-negations/" target="_blank" rel="noopener">1005. Maximize Sum Of Array After K Negations</a></p><p>翻译：给定一个 Number 数组 A, 有 K 次机会进行操作<code>A[i]=-A[i]</code>，使得数组逐项求和最大。</p><p>思路:</p><ol><li>负数从小到大消耗 K;</li><li>如果负数全部变成正数后，仍剩余<code>K&#39;</code>次，K 为偶数则跳过（因为偶数次翻转等于不翻转），K’ 为奇数则将排序后的 A 的最小值翻转。</li></ol><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; K</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> largestSumAfterKNegations = <span class="function"><span class="keyword">function</span>(<span class="params">A, K</span>) </span>&#123;</span><br><span class="line">  A.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; A.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span> &amp;&amp; K) &#123;</span><br><span class="line">      K--</span><br><span class="line">      A[i] = -A[i]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (K === <span class="number">0</span> || A[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (K % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    A.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    A[<span class="number">0</span>] = -A[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">    sum += A[j]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1006-Clumsy-Factorial"><a href="#1006-Clumsy-Factorial" class="headerlink" title="1006. Clumsy Factorial"></a>1006. Clumsy Factorial</h2><p><a href="https://leetcode.com/contest/weekly-contest-127/problems/clumsy-factorial/" target="_blank" rel="noopener">1006. Clumsy Factorial</a></p><p>翻译：给定一个数 n，把<code>n!</code>运算中的每个<code>*</code>运算符依次替换成<code>* / + -</code>循环，如：<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>，除法运算后直接取<code>floor</code>。</p><p>思路：<code>clumsy(10)</code>可以看成<code>(10 * 9 / 8 + 7) - ( 6 * 5 / 4 - 3) - (2 * 1)</code>。</p><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; N</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> clumsy = <span class="function"><span class="keyword">function</span>(<span class="params">N</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clumsyRegion = <span class="function">(<span class="params">start, len, flag</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">1</span>) <span class="keyword">return</span> flag ? <span class="number">1</span> : <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">2</span>) <span class="keyword">return</span> flag ? <span class="number">2</span> : <span class="number">-2</span></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">3</span>) <span class="keyword">return</span> flag ? <span class="number">6</span> : <span class="number">-6</span></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">4</span>)</span><br><span class="line">      <span class="keyword">return</span> flag</span><br><span class="line">        ? <span class="built_in">Math</span>.floor((start * (start - <span class="number">1</span>)) / (start - <span class="number">2</span>)) + (start - <span class="number">3</span>)</span><br><span class="line">        : -<span class="built_in">Math</span>.floor((start * (start - <span class="number">1</span>)) / (start - <span class="number">2</span>)) + (start - <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> i = N</span><br><span class="line">  <span class="keyword">for</span> (; i &gt; <span class="number">3</span>; i -= <span class="number">4</span>) &#123;</span><br><span class="line">    sum += clumsyRegion(i, <span class="number">4</span>, i === N)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i) &#123;</span><br><span class="line">    sum += clumsyRegion(i, i, i === N)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1007-Minimum-Domino-Rotations-For-Equal-Row"><a href="#1007-Minimum-Domino-Rotations-For-Equal-Row" class="headerlink" title="1007. Minimum Domino Rotations For Equal Row"></a>1007. Minimum Domino Rotations For Equal Row</h2><p><a href="https://leetcode.com/contest/weekly-contest-127/problems/minimum-domino-rotations-for-equal-row/" target="_blank" rel="noopener">1007. Minimum Domino Rotations For Equal Row</a></p><p>翻译：两个 Number 数组 A 和 B，通过交换相同位置的 A 和 B 元素，使得 A 或 B 中各个元素相同，求最小操作次数。</p><p>思路：</p><ol><li>先出现次数最多的元素 N，如果 N 出现的次数小于 A 的长度，那么无论如何交换都不会有完全相同的数组；</li><li>针对 N，遍历 A 和 B，维护两个数组 sumA 和 sumB，分别记录 A 和 B 变成完全相同数组需要的操作数；</li><li>如果<code>A[i]!==N</code>，<code>sumA++</code>，B 同理；</li><li>返回<code>Math.min(sumA, sumB)</code>。</li></ol><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; B</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDominoRotations = <span class="function"><span class="keyword">function</span>(<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dic = <span class="built_in">Array</span>(<span class="number">7</span>).fill(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    dic[A[i]]++</span><br><span class="line">    dic[B[i]]++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dic[j] &gt;= A.length) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dic[j] &lt; A.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> sumA = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> sumB = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; A.length; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[k] === j &amp;&amp; B[k] !== j) &#123;</span><br><span class="line">      sumB++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[k] !== j &amp;&amp; B[k] === j) &#123;</span><br><span class="line">      sumA++</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[k] !== j &amp;&amp; B[k] !== j) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sumA &lt; sumB ? sumA : sumB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a>1008. Construct Binary Search Tree from Preorder Traversal</h2><p><a href="https://leetcode.com/contest/weekly-contest-127/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">1008. Construct Binary Search Tree from Preorder Traversal</a></p><p>翻译：通过前序遍历序列生成 BST。</p><p>思路：分治法，序列第一项为（当前子树的）根节点，序列后第一个比根节点大的开始为右子树，其余的为左子树。</p><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; preorder</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> bstFromPreorder = <span class="function"><span class="keyword">function</span>(<span class="params">preorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (preorder.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> mid = preorder[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> tree = <span class="keyword">new</span> TreeNode(mid)</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; preorder.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder[i] &gt; mid) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tree.left = bstFromPreorder(preorder.slice(<span class="number">1</span>, i))</span><br><span class="line">  tree.right = bstFromPreorder(preorder.slice(i))</span><br><span class="line">  <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode-Contest-127&quot;&gt;&lt;a href=&quot;#LeetCode-Contest-127&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Contest 127&quot;&gt;&lt;/a&gt;LeetCode Contest 127&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://lynnjs.com/categories/Algorithm/"/>
    
    
      <category term="LeetCode" scheme="http://lynnjs.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>深入理解HTTPS</title>
    <link href="http://lynnjs.com/ck11ywqxn001lv8fy4gw7d1ui/"/>
    <id>http://lynnjs.com/ck11ywqxn001lv8fy4gw7d1ui/</id>
    <published>2019-03-08T06:09:26.000Z</published>
    <updated>2019-09-27T10:03:18.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解-HTTPS"><a href="#深入理解-HTTPS" class="headerlink" title="深入理解 HTTPS"></a>深入理解 HTTPS</h1><p>在春天的面试过程中，HTTP/HTTPS 作为网络基础的一部分，几乎个面试官都有问到。本文将从网络协议开始，分析 HTTPS 如何做到相对安全的网络传输。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li>使用数字签名、数字证书建立 SSL 连接</li><li>使用连接时的随机数生成对称密钥加密报文</li></ul><h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>未经过加密的 HTTP 报文在传输时，主要面临三个问题</p><ol><li>明文传输导致敏感信息泄露</li><li>易遭受 MitM 攻击</li><li>易遭篡改</li></ol><p>而 HTTPS 在 HTTP 的基础之上，在应用层下的表示层进行 SSL 加/解密，使得明文信息受到保护。</p><h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><p>常用的加密方式可以分成两种</p><ul><li>对称密钥加密</li><li>非对称密钥加密（公开密钥加密）</li></ul><p>对称密钥加密在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。优点是加解密速度快，缺点是双方需要获取相同秘钥。</p><p>非对称密钥需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。而且知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。优点是较为安全，只要私钥不泄露，传输就能保证单向的安全；缺点是加/解密速度较慢。</p><p>所以，HTTPS 的传输过程可以分成两步：1. 使用非对称密钥建立连接，交换生成对称密钥的必要信息；2. 使用生成的对称密钥加密 HTTP 报文。</p><h2 id="数字证书与数字签名"><a href="#数字证书与数字签名" class="headerlink" title="数字证书与数字签名"></a>数字证书与数字签名</h2><p>数字证书是由权威公正的第三方机构（CA）发放的身份凭证。</p><p>CA 机构内部有单独的一对非对称密钥，C 和 C’。私钥 C’保存在 CA 机构的服务器中，公钥则存在于每个浏览器的内部。</p><p>假设服务器 S 对应的域名为 S.com，S 首先在服务器内生成一对<code>非对称密钥</code>S 和 S’，妥善保存<code>私钥</code>，将<code>公钥</code>和其他必要的信息发送给 CA 进行认证。CA 核实确认 S 提交的信息无误后，把所有信息进行一次哈希运算，得到近乎唯一的字符串。再用 CA 的<code>私钥C&#39;</code>加密该字符串，得到的就是数字证书的<code>数字签名</code>，把以上信息合起来，就是 S 服务器的<code>数字证书</code>。</p><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><h3 id="Client-hello-amp-Server-hello"><a href="#Client-hello-amp-Server-hello" class="headerlink" title="Client hello &amp; Server hello"></a>Client hello &amp; Server hello</h3><p>当客户端 B 发起 SSL 握手时，向服务器 S 请求证书并发送随机数，S 返回对应域名的数字证书、随机数和加密方式等等。</p><h3 id="Certificate-Request-amp-Certificate-Verify"><a href="#Certificate-Request-amp-Certificate-Verify" class="headerlink" title="Certificate Request &amp; Certificate Verify"></a>Certificate Request &amp; Certificate Verify</h3><p>客户端获取到证书，用浏览器内置的 CA 公钥 C，解密该证书的<code>数字签名</code>部分，同时对数字证书的其他部分做一次哈希运算，如果得到相同的字符串，则证明该证书没有篡改过，也就证明了该服务器的公钥是 S 的公钥。</p><h3 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h3><p>客户端确认了数字证书的正确性之后，会用第一次握手获得的<code>公钥S</code>，加密一个随机数，发送给服务器。</p><p>这一过程是<strong>单向安全</strong>的，因为通过公钥 S 加密的数据，只有私钥 S’才能够解密。而私钥只保存在服务器中。这也就意味着无论是采用中间人攻击还是篡改，都无法威胁到这一次传输的正确性。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>三次握手结束之后，连接双方分别采用商定的算法和三个随机数算出对称密钥<code>K</code>。此时的对称密钥是安全的，因为生成所用的随机数其中一个是绝对安全的，同时对称密钥也没有在网络上传输。</p><p>此后 SSL 链接都经过对称密钥加密，防止了中间人攻击和篡改。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.amazon.cn/dp/B008XFDQ14/" target="_blank" rel="noopener">HTTP 权威指南</a></li><li><a href="https://blog.csdn.net/yuanmengong886/article/details/73557464" target="_blank" rel="noopener">HTTPS – CSDN</a></li><li><a href="https://www.jianshu.com/p/7158568e4867" target="_blank" rel="noopener">SSL 握手过程 –简书</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">对称密钥 – Wikipedia</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">非对称密钥 –Wikipedia</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解-HTTPS&quot;&gt;&lt;a href=&quot;#深入理解-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;深入理解 HTTPS&quot;&gt;&lt;/a&gt;深入理解 HTTPS&lt;/h1&gt;&lt;p&gt;在春天的面试过程中，HTTP/HTTPS 作为网络基础的一部分，几乎个面试官
      
    
    </summary>
    
      <category term="前端基础" scheme="http://lynnjs.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="HTTP" scheme="http://lynnjs.com/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://lynnjs.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>从零开始node（四）：工具</title>
    <link href="http://lynnjs.com/ck11ywqxc0013v8fyg3lsm5g5/"/>
    <id>http://lynnjs.com/ck11ywqxc0013v8fyg3lsm5g5/</id>
    <published>2018-10-21T11:06:45.000Z</published>
    <updated>2019-09-27T10:03:18.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始-node（四）：工具"><a href="#从零开始-node（四）：工具" class="headerlink" title="从零开始 node（四）：工具"></a>从零开始 node（四）：工具</h1><blockquote><p>工欲善其事，必先利其器。</p></blockquote><a id="more"></a><h2 id="Linux-下的安装"><a href="#Linux-下的安装" class="headerlink" title="Linux 下的安装"></a>Linux 下的安装</h2><p>在 Windows 和 macOS 平台，node 都有可视化界面来进行安装，在 Linux 平台就需要使用命令行来安装。常用的方法有以下几种：</p><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p>比如 ubuntu 的 apt，使用这种方法安装 node 的缺陷是版本不可控，且更新较慢。</p><h3 id="下载源码编译安装"><a href="#下载源码编译安装" class="headerlink" title="下载源码编译安装"></a>下载源码编译安装</h3><p>使用这种方法需要一个单核能力较强的 CPU，由于我在日常开发的时候使用的都是云服务器，1Core1G 的配置使编译过程变得非常的长。</p><h3 id="下载编译后的包"><a href="#下载编译后的包" class="headerlink" title="下载编译后的包"></a>下载编译后的包</h3><p>使用 curl 或者 wget 工具在 nodejs 官网下载已经编译好的包，如<code>https://nodejs.org/dist/latest/node-v10.12.0-linux-x64.tar.gz</code>，解压后 cp 到/usr/local 即可使用。缺点是难以进行版本管理。</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h3 id="nvm-n"><a href="#nvm-n" class="headerlink" title="nvm/n"></a>nvm/n</h3><ul><li>n</li></ul><p>n 是一个 npm 上的包，也就是说安装了 npm node 才可以安装 n，使用过程非常简单，只需一个命令<code>n</code>就可以使用上下箭头来切换 node 版本，而且切换版本的时候全局安装的包不受影响。缺点是不支持 Windows。</p><ul><li>nvm</li></ul><p>nvm 是一个独立的软件，在*nix，macOS，Windows 都有稳定的表现，而且可以实现不同的终端窗口使用不同版本的 node。缺点是切换版本的时候全局安装的包也会随之切换。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>从日常开发到正式部署上线，肯定不会采用<code>node app.js</code>的方法来启动 node 进程，因为随时有可能退出，并且会随着命令行窗口的关闭而关闭。在这里介绍三种守护进程用的包，<code>supervisor</code>/<code>forever</code>/<code>pm2</code></p><h3 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h3><p>一般用于开发环境，在保存代码后不用手动重启进程，supervisor 会自动重启，类似的还有 nest.js 脚手架默认使用的工具 nodemon。</p><h3 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h3><p>forever 是一个简单的工具，仅用于保持脚本持续运行，虽然它也有日志工具，但是在管理大型集群的情况下还是略显吃力。在我的使用历史来看，forever 守护博客最长曾经保持过两个月不宕机（不排除服务器不稳定的原因）</p><h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><p>相比于前两种工具，pm2 就显得更加专业了，不仅可以守护进程，还可以做负载均衡、日志管理、状态监控等，满足了大型 node 项目的稳定运行。详细使用参见：<a href="https://pm2.io/doc/zh/runtime/quick-start/" target="_blank" rel="noopener">pm2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从零开始-node（四）：工具&quot;&gt;&lt;a href=&quot;#从零开始-node（四）：工具&quot; class=&quot;headerlink&quot; title=&quot;从零开始 node（四）：工具&quot;&gt;&lt;/a&gt;从零开始 node（四）：工具&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;工欲善其事，必先利其器。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="node" scheme="http://lynnjs.com/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始 node（三）：多进程和集群</title>
    <link href="http://lynnjs.com/ck11ywqxk001dv8fygr6qcpi7/"/>
    <id>http://lynnjs.com/ck11ywqxk001dv8fygr6qcpi7/</id>
    <published>2018-10-17T11:37:58.000Z</published>
    <updated>2019-09-27T10:03:18.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始-node（三）：多进程和集群"><a href="#从零开始-node（三）：多进程和集群" class="headerlink" title="从零开始 node（三）：多进程和集群"></a>从零开始 node（三）：多进程和集群</h1><p>在我们日常开发中，对于写好的 node 项目，使用<code>node app.js</code>即可启动。但是在大型项目，并发要求较高的情况下，单一的 node 进程不足以应对。</p><p>这篇博客从多进程和集群稳定性两个角度来分析 node 项目走向集群的原理。</p><a id="more"></a><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>Node 提供了 child_process 模块来创建子进程，通过调用 child_process.fork()来实现进程的复制。这种模式叫做<code>Master-Worker模式</code>，也叫作主从模式。主进程负责调度，工作进程处理业务。</p><p>这里要普及一下<code>进程</code>和<code>线程</code>的区别，进程占有资源（内存，总线，缓存，管道等），是操作系统进行资源调度的基本单位，是系统中一个互相较为独立的工作空间；线程占有的是 CPU 时间，在 CPU 调度中线程比较常见，线程不占有资源，存在于进程中。</p><p>也就是说两个线程互相通信需要额外的操作，实现<code>进程间通信（IPC, Inter-Process Communication）</code>的方法有很多，比如：<code>命名管道</code>，<code>匿名管道</code>，<code>socket</code>，<code>信号量</code>，<code>共享内存</code>，<code>消息队列</code>，<code>Domain Socket</code>等，Node 采用的是 IPC 管道，通过 libuv 抽象，windows 底层采用命名管道，*nix 系统采用 Unix Domain Socket 实现。在应用层面表现为 message s 事件和 send()方法。</p><p>来看一段创建多进程的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</span><br><span class="line"><span class="keyword">var</span> child1 = cp.fork(<span class="string">"child.js"</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = cp.fork(<span class="string">"child.js"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"net"</span>).createServer()</span><br><span class="line">server.listen(<span class="number">80</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  child1.send(<span class="string">"server"</span>, server)</span><br><span class="line">  child2.send(<span class="string">"server"</span>, server)</span><br><span class="line">  server.close()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;)</span><br><span class="line">  res.end(<span class="string">"handled by child, pid is "</span> + process.pid + <span class="string">"\n"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">process.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m, tcp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === <span class="string">"server"</span>) &#123;</span><br><span class="line">    tcp.on(<span class="string">"connection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">      server.emit(<span class="string">"connection"</span>, socket)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在主从模式中，数据可以由主进程获取然后转发到各个进程中，但是这种方式并不高效。另一种方法是各个进程分别监听该端口，以抢占式处理请求。</p><p>在日常的开发过程中经常出现端口被占用的情况，所以在我们日常的认知中是一个端口只能由一个进程监听。事实上，多个进程是可以监听同一个端口的，只是由于我们分别启动进程监听端口时，socket 套接字的文件描述符各不相同，所以产生了错误。</p><blockquote><p>Node 底层对每个端口监听都设置了 SO_REUSEADDR 选项，这个选项的涵义是不同进程可以就相同的网卡和端口进行监听，这个服务器端套接字可以被不同的进程复用。由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口时就会失败。但对于 send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。</p></blockquote><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>本文从三个角度来简单介绍一下 node 集群管理需要注意的问题：</p><ul><li>负载均衡</li><li>平滑重启</li><li>状态共享</li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>由于这些进程对于连接是抢占式的，也就是说，当连接进入端口时，所有进程都会被唤起，最终却只有一个进程能够获得连接，其他进程再次进入休眠。这种现象叫做<code>惊群</code>。</p><p>这时就需要主进程来决定连接的分配问题。</p><p>使用 pm2 和 nginx 可以方便的进行负载均衡，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start app.js -i 4</span><br></pre></td></tr></table></figure><p>来启动 4 个 app.js 进程。下一篇会有详细介绍</p><p>为此 Node 采用的策略叫<code>Round-Robin</code>，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作<br>进程。分发的策略是在 N 个工作进程中，每次选择第 <code>i = (i + 1) mod n</code> 个进程来发送连接。在 cluster<br>模块中启用它的方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用Round-Robin</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_RR</span><br><span class="line"><span class="comment">// 不启用Round-Robin</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_NONE</span><br></pre></td></tr></table></figure><p>或者在环境变量中设置 <code>NODE_CLUSTER_SCHED_POLICY</code> 的值，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NODE_CLUSTER_SCHED_POLICY=rr</span><br><span class="line"><span class="keyword">export</span> NODE_CLUSTER_SCHED_POLICY=none</span><br></pre></td></tr></table></figure><p>大致类似于 CPU 调度的时间片轮转法。</p><h3 id="平滑重启"><a href="#平滑重启" class="headerlink" title="平滑重启"></a>平滑重启</h3><p>使用 pm2 的 reload 命令可以平滑的重启各个进程，也就是可以保证最少会有一个进程在工作中，而不是全部结束后重启。</p><p><em>自杀信号</em></p><p>在进程得知将要停止时，先向主进程发出“suicide”信号，主进程收到信号后会创建新工作进程来代替该进程，随后原进程处理完毕后即关闭。</p><p><em>限量重启</em></p><p>如果工作进程由于某些原因不断重启，可能会造成资源枯竭，这种频繁的重启有可能是由我们程序编写的原因造成的。如果在单位时间内进程重启超过一定次数，就会发出”giveup”事件,并放弃重启该工作进程。</p><h3 id="状态共享"><a href="#状态共享" class="headerlink" title="状态共享"></a>状态共享</h3><p>解决数据共享最直接、简单的方式就是通过第三方来进行数据存储，比如将数据存放到数据库、磁盘文件、缓存服务（如 Redis）中，所有工作进程启动时将其读取进内存中。</p><p>实现状态同步的一种方案是各个进程通过轮询的方式来获取数据更新，这种方式显然不合适，占用了大量的资源。<br>另一种方案是数据发生更改时主动通知各个进程，我们可以独立出来一个进程，通过轮询方式来判断状态的变化，一旦变化就主动通知进程变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从零开始-node（三）：多进程和集群&quot;&gt;&lt;a href=&quot;#从零开始-node（三）：多进程和集群&quot; class=&quot;headerlink&quot; title=&quot;从零开始 node（三）：多进程和集群&quot;&gt;&lt;/a&gt;从零开始 node（三）：多进程和集群&lt;/h1&gt;&lt;p&gt;在我们日常开发中，对于写好的 node 项目，使用&lt;code&gt;node app.js&lt;/code&gt;即可启动。但是在大型项目，并发要求较高的情况下，单一的 node 进程不足以应对。&lt;/p&gt;
&lt;p&gt;这篇博客从多进程和集群稳定性两个角度来分析 node 项目走向集群的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="http://lynnjs.com/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始 node（二）：Event Loop</title>
    <link href="http://lynnjs.com/ck11ywqyo003qv8fy4481mc40/"/>
    <id>http://lynnjs.com/ck11ywqyo003qv8fy4481mc40/</id>
    <published>2018-10-11T09:37:19.000Z</published>
    <updated>2019-09-27T10:03:18.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始-node（二）：Event-Loop"><a href="#从零开始-node（二）：Event-Loop" class="headerlink" title="从零开始 node（二）：Event Loop"></a>从零开始 node（二）：Event Loop</h1><blockquote class="blockquote-center">朱耀华</blockquote><p>第三、四章讲的是异步 I/O、异步编程，而实现异步的工具就是 Event Loop。在这里可以将浏览器环境和 Node 环境下的 Event Loop 对比来学习。</p><a id="more"></a><p>首先看一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timer1"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timer2"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise2"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器环境</span></span><br><span class="line"><span class="comment">// VM82:2 timer1</span></span><br><span class="line"><span class="comment">// VM82:5 promise1</span></span><br><span class="line"><span class="comment">// VM82:10 timer2</span></span><br><span class="line"><span class="comment">// VM82:13 promise2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node环境 v8.5.0</span></span><br><span class="line"><span class="comment">// tick2.js:2  timer1</span></span><br><span class="line"><span class="comment">// tick2.js:10 timer2</span></span><br><span class="line"><span class="comment">// tick2.js:5  promise1</span></span><br><span class="line"><span class="comment">// tick2.js:13  promise2</span></span><br></pre></td></tr></table></figure><p>产生原因就在于两种环境下的 Event Loop 策略和过程不同。</p><h2 id="浏览器环境下的-Event-Loop"><a href="#浏览器环境下的-Event-Loop" class="headerlink" title="浏览器环境下的 Event Loop"></a>浏览器环境下的 Event Loop</h2><p>浏览器环境下的异步操作分为两种：宏任务（macrotask）和微任务（microtask）。</p><p>宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering</p><p>微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver</p><p>重点来了：<br>在每一次 Event Loop 中，从宏任务队列中取出一个任务执行，该任务执行的过程中微任务的回调函数加入到微任务队列中，当宏任务执行结束，开始执行微任务，直到队列清空。再取出下一个宏任务重复以上操作。</p><p>举个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    i == <span class="number">999</span> &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 3 5 4 1</span></span><br></pre></td></tr></table></figure><p>看懂这个你才算真正理解了浏览器端的 Event Loop。</p><p>流程分析：</p><ol><li>首先从宏任务队列中取出一个任务即 script，顺序执行。</li><li>setTimeOut 立即执行（注意宏任务微任务区分的是回调），将回调函数加入宏任务队尾，继续执行。</li><li>new Promise 立即执行构造函数，输出 2，3，在循环 1000 次之后执行了 resolve，将 then 的回调函数加入微任务队尾。</li><li>输出 5，该宏任务执行完成，开始执行微任务队列，取出队首 then 的回调函数执行，输出 4。</li><li>微任务队列清空，取出宏任务队首的 setTimeOut 回调，输出 1。</li></ol><p>这时我们来重新分析一下开始的栗子：</p><ol><li>setTimeOut1，2 分别加入宏任务队列。</li><li>script 执行结束，微任务队列为空，取出宏任务队列 setTimeOut1 的回调，输出 timer1，promise 加入微任务队列。</li><li>取出微任务队列队首，输出 promise1。</li><li>取出 setTimeOut2 的回调，输出 timer2，promise 加入微任务队列。</li><li>取出微任务队列队首，输出 promise2。</li></ol><p>至此，浏览器端的 Event Loop 分析完成</p><h2 id="Node-环境下的-Event-Loop"><a href="#Node-环境下的-Event-Loop" class="headerlink" title="Node 环境下的 Event Loop"></a>Node 环境下的 Event Loop</h2><p>分析 Node.js <a href="https://github.com/libuv/libuv/blob/v1.x/src/unix/core.c#L348-L397" target="_blank" rel="noopener">libuv 库源码</a>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_run</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    <span class="comment">// timers阶段</span></span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    <span class="comment">// I/O callbacks阶段</span></span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    <span class="comment">// idle阶段</span></span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    <span class="comment">// prepare阶段</span></span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line">    <span class="comment">// poll阶段</span></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    <span class="comment">// check阶段</span></span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    <span class="comment">// close callbacks阶段</span></span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><ul><li>timers 阶段：执行 timer（setTimeout、setInterval）的回调</li><li>I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调</li><li>idle, prepare 阶段：仅 node 内部使用</li><li>poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close 事件回调</li></ul><p>可以这样理解：<br>在 node 中每一个阶段都维护一个宏任务和微任务队列。在宏任务执行结束之后，执行一次微任务队列中的任务。在等待 I/O 的时候，node 线程会阻塞在 poll 阶段。</p><h3 id="timers-阶段"><a href="#timers-阶段" class="headerlink" title="timers 阶段"></a>timers 阶段</h3><p>timers 阶段 Node 会检查 timer 是否已过期，如果有就把它的回调压入任务队列中执行。但是 js 的定时器并不靠谱，因为在定时器过期的时候，js 的线程可能会在执行另外一个任务。</p><p>setTimeOut 和 setImmediate 的执行顺序也是不固定的。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"timeout"</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"immediate"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看起来任务是从 timers 阶段开始的，但是如果我们从 poll 阶段的 I/O 开始执行这段代码，就是 setImmediate 先执行，因为 poll 阶段之后就是 check 阶段，执行 setImmediate 代码。</p><h3 id="poll-阶段"><a href="#poll-阶段" class="headerlink" title="poll 阶段"></a>poll 阶段</h3><p>当有已超时的 timer，执行它的回调函数。同步执行 poll 队列里的回调，直到队列为空或执行的回调达到系统上限，而后检查有无预设的 setImmediate()，分两种情况：</p><ul><li>有预设的 setImmediate(),poll 阶段进入 check 阶段，并执行 check 阶段的任务队列；</li><li>无预设的 setImmediate()，阻塞在该阶段等待。如果 timer 队列非空，则开始下一轮事件循环，重新进入到 timer 阶段。</li></ul><h3 id="check-阶段"><a href="#check-阶段" class="headerlink" title="check 阶段"></a>check 阶段</h3><p>setImmediate()的回调加入到 check 队列中顺序执行。</p><p>这时候文章开始的例子就比较容易理解了。我们对照着来看其他几个类似案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入两个setImmediate()的回调函数</span></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setImmediate延迟执行1"</span>)</span><br><span class="line">  <span class="comment">// 进入下次循环</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"nextTick1"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"nextTick2"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setImmediate延迟执行2"</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"正常执行"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常执行</span></span><br><span class="line"><span class="comment">// setImmediate延迟执行1</span></span><br><span class="line"><span class="comment">// setImmediate延迟执行2</span></span><br><span class="line"><span class="comment">// nextTick1</span></span><br><span class="line"><span class="comment">// nextTick2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br></pre></td></tr></table></figure><p>两个 setImmediate 先执行，且<code>nextTick</code>队列优先清空，然后再执行其他队列。</p><hr><p>至此，js 执行的两个环境的异步 Event Loop 执行顺序已经介绍清楚。大家可以自己动手来试试执行一下。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.amazon.cn/dp/B00GOM5IL4" target="_blank" rel="noopener">深入浅出 Node.js</a></li><li><a href="http://lynnelv.github.io/js-event-loop-nodejs" target="_blank" rel="noopener">深入理解 js 事件循环机制（Node.js 篇）</a></li><li><a href="https://zhuanlan.zhihu.com/p/33090541" target="_blank" rel="noopener">知乎专栏</a></li><li><a href="https://github.com/libuv/libuv/blob/v1.x/src/unix/core.c#L348-L397" target="_blank" rel="noopener">Node-libuv 源码</a></li><li><a href="https://juejin.im/post/5ba34e54e51d450e5162789b#heading-21" target="_blank" rel="noopener">掘金技术征文</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从零开始-node（二）：Event-Loop&quot;&gt;&lt;a href=&quot;#从零开始-node（二）：Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;从零开始 node（二）：Event Loop&quot;&gt;&lt;/a&gt;从零开始 node（二）：Event Loop&lt;/h1&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;朱耀华&lt;/blockquote&gt;

&lt;p&gt;第三、四章讲的是异步 I/O、异步编程，而实现异步的工具就是 Event Loop。在这里可以将浏览器环境和 Node 环境下的 Event Loop 对比来学习。&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="http://lynnjs.com/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始node（一）：模块机制</title>
    <link href="http://lynnjs.com/ck11ywqx90011v8fy9ijjqakn/"/>
    <id>http://lynnjs.com/ck11ywqx90011v8fy9ijjqakn/</id>
    <published>2018-10-09T11:18:10.000Z</published>
    <updated>2019-09-27T10:03:18.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始-node（一）：模块机制"><a href="#从零开始-node（一）：模块机制" class="headerlink" title="从零开始 node（一）：模块机制"></a>从零开始 node（一）：模块机制</h1><blockquote class="blockquote-center">朱耀华</blockquote><p>之前粗略的阅读过《nodejs 权威指南》，但是这本书有点类似于字典或者文档，比较重视核心模块和接口的使用。</p><p>这次从头开始阅读<a href="https://www.amazon.cn/dp/B00GOM5IL4" target="_blank" rel="noopener">《深入浅出 Node.js》</a>，也许这本书比较久远了，但是比较重视原理层面，适合仔细阅读。</p><a id="more"></a><p>node 中引入模块，需要经历三个步骤</p><ol><li>路径分析</li><li>文件定位</li><li>编译执行</li></ol><p>在 Node 中，模块分为两类：<code>核心模块</code>和<code>文件模块</code>。</p><p>核心模块是 node 提供的模块，在 node 源代码编译的过程中，编译进了二进制执行文件。在 node 进程启动时，部分核心模块就被直接加在今内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉。核心模块的加载速度是最快的。</p><p>文件模块是用户编写的模块在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程。</p><p>require()方法对相同模块的二次加载采用缓存优先的方式。</p><h2 id="路径分析"><a href="#路径分析" class="headerlink" title="路径分析"></a>路径分析</h2><p>require()的参数——模块标识符分为以下几类</p><ul><li>核心模块，如 http、fs</li><li>相对路径/绝对路径的文件模块</li><li>自定义的文件模块</li></ul><p>自定义的文件模块查找策略是：</p><ul><li>当前文件目录下的 node_modules</li><li>父目录下的 node_modules</li><li>逐级递归，知道根目录下的 node_modules</li></ul><h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p>Node 会按照.js .json .node 的顺序给模块标识符添加扩展名，在文件定位的过程中是同步阻塞的，所以为标识符带上扩展名会加快速度。</p><p>有时候文件定位后得到一个目录，这时首先查找 package.json，从中取出 main 属性指定文件名定位。以上步骤失败则会把 index.js index.json index.node 作为默认文件名。</p><h2 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h2><p>对于不同的文件扩展名，其载入方法也不同。</p><ul><li>js 文件：通过 fs 模块同步读取文件后编译执行</li><li>node 文件：这是用 C/C++编写扩展文件，用 dlopen()方法加载最后编译生成的文件</li><li>json 文件：fs 同步读取后，JSON.parse()解析结果</li></ul><p>编译成功的模块会将其文件路径作为索引缓存在 Module._cache 上。</p><h3 id="JavaScript-模块的编译"><a href="#JavaScript-模块的编译" class="headerlink" title="JavaScript 模块的编译"></a>JavaScript 模块的编译</h3><p>在编译的过程中，Node 对 JavaScript 文件内容进行了头尾包装，一个正常的 JavaScript 文件包装成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">"math"</span>)</span><br><span class="line">  exports.area = <span class="function"><span class="keyword">function</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>CommonJS 规范中存在着 require、exports、module、__filename、__dirname 这几个变量存在，就是由此而来，同事还对每个模块文件之间进行了作用域隔离。</p><p>*关于 exports 和 module.exports，exports 是对 module.exports 的引用，所以直接对 exports 赋值会造成指针丢失，并不会导出模块。</p><h3 id="C-C-模块的编译"><a href="#C-C-模块的编译" class="headerlink" title="C/C++模块的编译"></a>C/C++模块的编译</h3><p>node 文件是 C/C++编写编译后生成的，所以这一部分只有加载和执行，执行效率较高。</p><p>dlopen()方法在 windows 和*nix 平台有不同的实现，通过 libuv 兼容层进行封装。</p><h3 id="JSON-文件的编译"><a href="#JSON-文件的编译" class="headerlink" title="JSON 文件的编译"></a>JSON 文件的编译</h3><p>读取到内容之后，调用 JSON.parse()得到对象，将其赋给 exports。</p><p>内建模块：使用 C/C++编写，主要供其他模块使用的模块，比如 fs 模块。JavaScript 核心模块主要扮演的职责有两类：一类是作为 C/C++内建模块的封装层和桥接层，<br>供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。</p><p>扩展模块：用户使用 C/C++编写的模块</p><p>*有关内建模块和扩展模块的编译和加载以后再讨论……</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从零开始-node（一）：模块机制&quot;&gt;&lt;a href=&quot;#从零开始-node（一）：模块机制&quot; class=&quot;headerlink&quot; title=&quot;从零开始 node（一）：模块机制&quot;&gt;&lt;/a&gt;从零开始 node（一）：模块机制&lt;/h1&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;朱耀华&lt;/blockquote&gt;

&lt;p&gt;之前粗略的阅读过《nodejs 权威指南》，但是这本书有点类似于字典或者文档，比较重视核心模块和接口的使用。&lt;/p&gt;
&lt;p&gt;这次从头开始阅读&lt;a href=&quot;https://www.amazon.cn/dp/B00GOM5IL4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《深入浅出 Node.js》&lt;/a&gt;，也许这本书比较久远了，但是比较重视原理层面，适合仔细阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="http://lynnjs.com/categories/node/"/>
    
    
  </entry>
  
  <entry>
    <title>一个栗子引发的思考</title>
    <link href="http://lynnjs.com/ck11ywqx7000zv8fym906eg5e/"/>
    <id>http://lynnjs.com/ck11ywqx7000zv8fym906eg5e/</id>
    <published>2018-09-13T11:33:09.000Z</published>
    <updated>2019-09-27T10:03:18.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个栗子引发的思考"><a href="#一个栗子引发的思考" class="headerlink" title="一个栗子引发的思考"></a>一个栗子引发的思考</h1><p>前情提要：小 Foo 和小 Bar 是某互联网公司的同事。有一天，小 Foo 交给小 Bar 一个任务……</p><a id="more"></a><h2 id="轮询-Polling"><a href="#轮询-Polling" class="headerlink" title="轮询(Polling)"></a>轮询(Polling)</h2><p>小 Foo 说明任务之后并没有回到自己的工位，而是站在小 Bar 后边执行了以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Bar.getRes()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"做完了吗？做完了吗？？"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就叫<code>轮询</code></p><h2 id="阻塞-Blocking"><a href="#阻塞-Blocking" class="headerlink" title="阻塞 (Blocking)"></a>阻塞 (Blocking)</h2><p>小 Foo 说明任务之后并没有回到自己的工位，而是站在小 Bar 后边执行了以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Bar.getRes()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"做完了吗？做完了吗？？"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时小 Foo 是<code>阻塞</code>的，因为 Foo 在等 Bar 的结果什么也没做。</p><h2 id="非阻塞-non-Blocking"><a href="#非阻塞-non-Blocking" class="headerlink" title="非阻塞 (non-Blocking)"></a>非阻塞 (non-Blocking)</h2><p>小 Foo 说明任务之后并没有回到自己的工位，而是站在小 Bar 后边执行了以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Bar.getRes()) &#123;</span><br><span class="line">  Foo.play(<span class="string">"炉石传说"</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"做完了吗？做完了吗？？"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时小 Foo 是<code>非阻塞</code>的，因为 Foo 在等 Bar 的时候还玩了炉石传说。</p><h2 id="同步-Synchronous"><a href="#同步-Synchronous" class="headerlink" title="同步 (Synchronous)"></a>同步 (Synchronous)</h2><p>小 Foo 说明任务之后，小 Bar 说：“你先回去吧，做完我告诉你”，小 Foo 说：“不行，我就要在这看着你做！你做完了我才能玩炉石传说！”并执行了以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Bar.getRes()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"做完了吗？做完了吗？？"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Foo.play(<span class="string">"炉石传说"</span>)</span><br></pre></td></tr></table></figure><p>此时的工作是<code>同步</code>的，因为只有 Foo Bar 做完了这个工作 Foo 才能玩炉石传说。</p><h2 id="异步-Asynchronous"><a href="#异步-Asynchronous" class="headerlink" title="异步 (Asynchronous)"></a>异步 (Asynchronous)</h2><p>小 Foo 说明任务之后，小 Bar 说：“你先回去吧，做完我告诉你”，小 Foo 说：“溜了溜了”，并执行了以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bar.addEventListener(<span class="string">"我做完了"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"你总算做完了"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">Foo.play(<span class="string">"炉石传说"</span>)</span><br></pre></td></tr></table></figure><p>此时的工作是<code>异步</code>的，因为这个工作还没做完，Foo 已经开始了下一个活动（玩炉石传说）。</p><h2 id="并发-Concurrent"><a href="#并发-Concurrent" class="headerlink" title="并发 (Concurrent)"></a>并发 (Concurrent)</h2><p>小 Foo 说明任务 A 之后，发现自己还需要让小 Bar 做任务 B。</p><p>小 Bar 先做了任务 A，或者先做了任务 B，或者一会做任务 A 一会做任务 B，或者任务 A 任务 B 同时做，总之，在下班之前交付给了小 Foo。</p><p>此时的工作 AB 是宏观<code>并发</code>的，因为在同一时间间隔（下班之前）里，AB 被执行。</p><h2 id="并行-Parallel"><a href="#并行-Parallel" class="headerlink" title="并行 (Parallel)"></a>并行 (Parallel)</h2><p>小 Foo 说明任务 A 之后，发现自己还需要让小 Bar 做任务 B。</p><p>小 Bar 觉得自己非常厉害，所以他左手做任务 A，右手做任务 B。</p><p>此时的工作 AB 在某些时间点是<code>并行</code>，因为在一些时间点上，AB 是同时被执行的。</p><h2 id="串行-Serial"><a href="#串行-Serial" class="headerlink" title="串行 (Serial)"></a>串行 (Serial)</h2><p>小 Foo 说明任务 A 之后，发现自己还需要让小 Bar 做任务 B。</p><p>小 Bar 觉得自己非常菜，所以精心规划好了工作时间，先做 A，然后做 B，最后检查一遍 A。</p><p>此时的工作 AB 是微观<code>串行</code>的，因为在同一时间点，只有一个工作被执行。</p><h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流 (throttle)"></a>函数节流 (throttle)</h2><p>小 Foo 说明任务之后并没有回到自己的工位，而是站在小 Bar 后边执行了以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cui = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"做完了吗？做完了吗？？"</span>)</span><br><span class="line">setInterval(cui, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>小 Bar 觉得小 Foo 这样做很不利于工作，于是给小 Foo 加了一层函数，这样小 Foo 无论怎么想催，一分钟最多催一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _self = fn,</span><br><span class="line">    timer,</span><br><span class="line">    firstTime = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>,</span><br><span class="line">      _me = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">      _self.apply(_me, args)</span><br><span class="line">      <span class="keyword">return</span> (firstTime = <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeOut(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearTimeOut(timer)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      _self.apply(_me, args)</span><br><span class="line">    &#125;, interval)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cui = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"做完了吗？做完了吗？？"</span>)</span><br><span class="line">throttle(cui, <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line"><span class="comment">// 参考《JavaScript设计模式与开发实践》</span></span><br></pre></td></tr></table></figure><p>这个方法叫做<code>函数节流</code></p><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖 (debounce)"></a>函数防抖 (debounce)</h2><p>小 Foo 说明任务之后并没有回到自己的工位，他觉得小 Bar 写的太慢了，于是执行了以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bar.addEventListener(<span class="string">"input"</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"做完了吗？做完了吗？？"</span>))</span><br></pre></td></tr></table></figure><p>这样小 Bar 每输入一个字，就会听到小 Foo 全方位的“指导”。于是小 Bar 用了一个方法，每次自己停下来思考的时候，小 Foo 就会指导他。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, interval = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, interval)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.addEventListener(<span class="string">"input"</span>, debounce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"做完了吗？做完了吗？？"</span>), <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p>这个方法叫做<code>函数防抖</code>，可用于：搜索框实时显示（不需要每输入一个字都进行一次搜索）</p><p>小Foo和小Bar的故事还在继续……</p><p><small>朱耀华_20180913</small></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一个栗子引发的思考&quot;&gt;&lt;a href=&quot;#一个栗子引发的思考&quot; class=&quot;headerlink&quot; title=&quot;一个栗子引发的思考&quot;&gt;&lt;/a&gt;一个栗子引发的思考&lt;/h1&gt;&lt;p&gt;前情提要：小 Foo 和小 Bar 是某互联网公司的同事。有一天，小 Foo 交给小 Bar 一个任务……&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://lynnjs.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>跨域和CORS</title>
    <link href="http://lynnjs.com/ck11ywqy2002jv8fyevwq93vy/"/>
    <id>http://lynnjs.com/ck11ywqy2002jv8fyevwq93vy/</id>
    <published>2018-09-02T09:50:21.000Z</published>
    <updated>2019-09-27T10:03:18.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域和CORS"><a href="#跨域和CORS" class="headerlink" title="跨域和CORS"></a>跨域和CORS</h1><p>最近的一个项目在对接的时候，会报出以下错误：</p><blockquote><font color="red">OPTIONS <strong>*</strong> 401()</font><br><font color="red">Failed to load <strong>*</strong>: Response to preflight request doesn’t pass access conreol check : No ‘Access-Conrtrl-Allow-Origin’ header is present on the requested resoutce. Origin ‘<a href="http://localhost:10001&#39;" target="_blank" rel="noopener">http://localhost:10001&#39;</a> is not allowed access.</font></blockquote><p>直译过来是 OPTIONS 请求错误，response 的 header 里面没有 ‘Access-Conrtrl-Allow-Origin’字段。</p><p>如果在开发过程中看到这个错误的话就可以直接截图给后端让他改了（虽然产生原因在浏览器……</p><a id="more"></a><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>同源是指三个相同：</p><ul><li>协议</li><li>域名</li><li>端口</li></ul><p>如果这三个中间有任何一个不相同，则称之为不同源。<br>在浏览器中，如果源地址和目标地址不同源，则以下三种行为会受到同源策略限制：</p><ul><li>Cookie、LocalStorage 和 IndexDB 读取</li><li>Dom 获取</li><li>AJAX 请求</li></ul><h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>但是在平时的开发过程中，本地使用的服务器是 127.0.0.1，当然和后端的服务器不同源。这时候就不可避免地进行跨域请求。<br>目前在浏览器中对不同源的目标发送 XMLHttpRequest 或者 fetch 都会自动地进行 CORS（Cross-Origin-Resource-Share, 跨域资源共享)，用户和开发者使用起来和正常请求没有差别。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>上面的错误就是 CORS 的其中一个过程，如果将要发出的跨域请求满足以下条件，那么就属于 CORS 定义下的“简单请求”：</p><ol><li><p>请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li><p>HTTP 的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ol><p>简单请求和普通的请求区别是会在头部加上一个 Origin 字段，如果指定的源不在许可的范围内，就不会返回一个包含’Access-Control-Allow-Origin’的字段，浏览器会报出上面的第二个错误。</p><h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>上面的第一个错误：OPTIONS 401()，显示是 OPTIONS 方法的请求返回了一个 Unauthorized 状态码。<br>如果浏览器发出的跨域请求时非简单请求，那么就会先发出一个”preflight”(预检请求)，来检验源是否在服务器允许 CORS 的源列表内，如果返回的头部包含 Access-Control-Allow-Origin 字段而且值包含该源，那么浏览器会正常发出该请求。</p><p>那么现在错误原因已经很清晰了，首先由于 127.0.0.1 和服务器”不同源”，浏览器自动执行 CORS，非简单请求先发出 OPTIONS 预检，服务器返回的头部没有 Access-Control-Allow-Origin 字段，因此 options 报 401 错误。</p><p>解决办法：截图给后端（设置一下 Access-Control-Allow-Origin 添加 127.0.0.1 或者*（通配符）</p><p>有关于跨域的其他解决方案 JSONP、WebSocket，OPTIONS 请求返回的其他头部字段，请继续阅读参考资料中的博文。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP 访问控制（CORS）—— MDN</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器的同源策略——ruanyifeng</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li><li><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP 状态码——Wikipedia</a></li></ol><p><small>朱耀华_20180902</small></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;跨域和CORS&quot;&gt;&lt;a href=&quot;#跨域和CORS&quot; class=&quot;headerlink&quot; title=&quot;跨域和CORS&quot;&gt;&lt;/a&gt;跨域和CORS&lt;/h1&gt;&lt;p&gt;最近的一个项目在对接的时候，会报出以下错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;font color=&quot;red&quot;&gt;OPTIONS &lt;strong&gt;*&lt;/strong&gt; 401()&lt;/font&gt;&lt;br&gt;&lt;font color=&quot;red&quot;&gt;Failed to load &lt;strong&gt;*&lt;/strong&gt;: Response to preflight request doesn’t pass access conreol check : No ‘Access-Conrtrl-Allow-Origin’ header is present on the requested resoutce. Origin ‘&lt;a href=&quot;http://localhost:10001&amp;#39;&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://localhost:10001&amp;#39;&lt;/a&gt; is not allowed access.&lt;/font&gt;
&lt;/blockquote&gt;
&lt;p&gt;直译过来是 OPTIONS 请求错误，response 的 header 里面没有 ‘Access-Conrtrl-Allow-Origin’字段。&lt;/p&gt;
&lt;p&gt;如果在开发过程中看到这个错误的话就可以直接截图给后端让他改了（虽然产生原因在浏览器……&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://lynnjs.com/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="http://lynnjs.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 this</title>
    <link href="http://lynnjs.com/ck11ywqxq001sv8fy9fguevym/"/>
    <id>http://lynnjs.com/ck11ywqxq001sv8fy9fguevym/</id>
    <published>2018-08-26T13:47:00.000Z</published>
    <updated>2019-09-27T10:03:18.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解-this"><a href="#深入理解-this" class="headerlink" title="深入理解 this"></a>深入理解 this</h1><p>这篇文章主要参考<a href="https://www.amazon.cn/dp/B00W34DZ8K" target="_blank" rel="noopener">《你不知道的 JavaScript》</a>的<code>第2章—this全面解析</code></p><p>首先说结论：</p><blockquote><p>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p></blockquote><p>本文使用了大量代码来说明，请耐心阅读。</p><a id="more"></a><h2 id="两种误解"><a href="#两种误解" class="headerlink" title="两种误解"></a>两种误解</h2><h3 id="认为-this-指向”自己”"><a href="#认为-this-指向”自己”" class="headerlink" title="认为 this 指向”自己”"></a>认为 this 指向”自己”</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo: "</span> + num)</span><br><span class="line">  <span class="keyword">this</span>.count++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    foo(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.count)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.count)</span><br><span class="line"><span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面代码中的 this 并没有按照预期指向“自己”（foo）。结果是在全局作用域下创建了 count 变量，但是由于没有赋值，count 为 undefined，而<code>undefined++</code>返回的是 NaN，<code>NaN++</code>同理，所以最后输出的是 NaN。</p><h3 id="认为-this-指向“作用域”"><a href="#认为-this-指向“作用域”" class="headerlink" title="认为 this 指向“作用域”"></a>认为 this 指向“作用域”</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>this 并没有按照预期指向作用域也就是 bar=&gt;foo=&gt;window 这一作用域，而是输出了 window.a，也就是 undefined。</p><hr><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>this 的四条绑定规则分别是：默认绑定、隐式绑定、显式绑定和 new 绑定</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>默认绑定是无法应用其他三条规则时的默认规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2</span></span><br><span class="line"><span class="comment"> * foo在调用时使用的是没有任何修饰的函数引用，因此采用默认绑定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>在函数嵌套调用的时候也会默认绑定到全局</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">  baz()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>正常的隐式绑定的效果是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj1.foo()</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>隐式丢失</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"window"</span></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line">bar() <span class="comment">// "window"</span></span><br><span class="line"><span class="comment">//实际上是直接调用的foo()</span></span><br></pre></td></tr></table></figure><p>简单来说就是，函数的传递是靠引用的，也就是“指针”，所以当<code>bar = obj.foo</code>的时候，bar 已经和 obj 没有关系了，直接指向原来的 foo 函数。<br>这样的情况也会发生在函数作为参数传递到回调函数中的情况，使用时要注意。</p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>隐式绑定有一个缺陷，就是我们必须在一个对象内部包含一个指向函数的属性，显示绑定可以强制在某个对象上调用函数。在 function 类型的原型上都有 call()和 apply()方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>硬绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call(obj)</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">bar.call(<span class="built_in">window</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>硬绑定用于解决显式绑定下的绑定丢失问题。ES5 中提供了 Function.prototype.bind 方法用于硬绑定，返回一个硬绑定后的新函数。</p><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p>new 操作符在许多其他面向对象语言中都有，使用方法是<code>myClass = new MyClass()</code>，从而调用类的构造函数。但是在 JavaScript 中并不存在什么“构造函数”，只有对于函数的“构造调用”。<br>使用 new 操作符调用函数时会执行以下操作：</p><ol><li>创建新的对象，相当于创建字面量{}</li><li>构造函数指向 new 的函数 this.constructor = foo 该对象的原型链接到 Foo.prototype</li><li>新对象绑定到函数调用的 this</li><li>传入的参数赋给新对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar - <span class="keyword">new</span> foo(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bar.a)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>这四种规则的优先级，默认绑定是最低的。</p><p>显式绑定 &gt; 隐式绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo() <span class="comment">// 2</span></span><br><span class="line">obj2.foo() <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2) <span class="comment">// 3</span></span><br><span class="line">obj2.foo.call(obj1) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>显然，通过显示绑定调用已经隐式绑定的函数，最终的效果是显式的效果。</p><p>new &gt; 显式绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1)</span><br><span class="line">bar(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.a) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>new 操作符会检测硬绑定，并用新创建的 this 替换。</p><p>应用：预置参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = p1 + p2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>, <span class="string">"p1"</span>)</span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="string">"p2"</span>)</span><br><span class="line">baz.val <span class="comment">//p1p2</span></span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>使用了 new ? 绑定到新创建的对象</li><li>通过 call,apply 调用 ? 绑定到指定的对象</li><li>通过对象隐式调用 ? 绑定到该对象</li><li>使用默认绑定，严格模式下绑定到 undefined</li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数并不会应用以上四条规则，而是直接继承外层函数的 this，和平时用的<code>var me/self/that = this</code>一样的效果。（真香警告</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.amazon.cn/dp/B00W34DZ8K" target="_blank" rel="noopener">《你不知道的 JavaScript》</a></li><li><a href="https://www.amazon.cn/dp/B01251LYTW" target="_blank" rel="noopener">《JavaScript 专家编程》</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解-this&quot;&gt;&lt;a href=&quot;#深入理解-this&quot; class=&quot;headerlink&quot; title=&quot;深入理解 this&quot;&gt;&lt;/a&gt;深入理解 this&lt;/h1&gt;&lt;p&gt;这篇文章主要参考&lt;a href=&quot;https://www.amazon.cn/dp/B00W34DZ8K&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《你不知道的 JavaScript》&lt;/a&gt;的&lt;code&gt;第2章—this全面解析&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先说结论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文使用了大量代码来说明，请耐心阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://lynnjs.com/categories/JavaScript/"/>
    
    
      <category term="this" scheme="http://lynnjs.com/tags/this/"/>
    
      <category term="Note" scheme="http://lynnjs.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>读《JavaScript专家编程》</title>
    <link href="http://lynnjs.com/ck11ywqxt0020v8fy79mhmgo5/"/>
    <id>http://lynnjs.com/ck11ywqxt0020v8fy79mhmgo5/</id>
    <published>2018-08-22T12:02:50.000Z</published>
    <updated>2019-09-27T10:03:18.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读《JavaScript-专家编程》"><a href="#读《JavaScript-专家编程》" class="headerlink" title="读《JavaScript 专家编程》"></a>读《JavaScript 专家编程》</h1><p><a href="https://www.amazon.cn/dp/B01251LYTW" target="_blank" rel="noopener">《JavaScript 专家编程》</a>这本书刚开始读的时候有种能读一个月的错觉。但是实际上不到一周时间就读完了，原因在于这本书有点“头重脚轻”，前面讲的挺透彻，越到后面越放飞自我……再加上年代久远，有些工具已经不适用了，而且其中的一些有关于测试的内容还是在软件工程类别的书里深入了解吧。</p><h2 id="第-1-章-对象和原型"><a href="#第-1-章-对象和原型" class="headerlink" title="第 1 章 对象和原型"></a>第 1 章 对象和原型</h2><h3 id="对象概述"><a href="#对象概述" class="headerlink" title="对象概述"></a>对象概述</h3><ul><li>configurable：设置为 false 的时候，属性的描述符会被锁定，无法修改。</li><li>enumberable：设置为 false 的时候，属性不可以被遍历（阻止遍历，不是被隐藏起来）</li><li>writable：设置为 false 的时候，属性的值不可被改变</li><li>检视对象：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 返回对象属性特性的配置</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 返回对象全部属性的名字，包括那些不能枚举的</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(o)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 用来返回特定对象的原型，有时可以使用__proto__代替，但是仅可访问，设置时需要__proto__</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(o)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 分辨某个属性是否存在与对象实例中</span></span><br><span class="line"><span class="built_in">Object</span>.hasOwnProperty(<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 返回可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 如果对象不能扩展，属性也不能修改，返回true</span></span><br><span class="line"><span class="built_in">Object</span>.isFrozen()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 这个方法在对象额整个原型链中检查每一环，看传入的对象是否存在于其中</span></span><br><span class="line"><span class="built_in">Object</span>.isPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 使用Object.preventExtensions('o')来禁止扩展</span></span><br><span class="line"><span class="built_in">Object</span>.isExtensible()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 对象不可扩展&amp;&amp;属性都不可配置</span></span><br><span class="line"><span class="built_in">Object</span>.isSealed()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 使用一个基本类型的值来描述对象</span></span><br><span class="line"><span class="built_in">Object</span>.valueOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11. 与严格相等运算符类似，不需要强制转换时是否具有相同的值</span></span><br><span class="line"><span class="comment">// console.log(NaN===0/0) false</span></span><br><span class="line"><span class="comment">// Object.is(NaN,0/0) true</span></span><br><span class="line"><span class="built_in">Object</span>.is(foo,bar)</span><br></pre></td></tr></table></figure><ul><li>修改对象</li></ul><p>区分几个概念：</p><p>freeze：<del>增/删/改</del><br>seal：<del>增/删</del><br>preventExtensions：<del>增</del></p><ul><li>创建对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** new的四个步骤</span></span><br><span class="line"><span class="comment"> * 1. 创建新的对象，相当于创建字面量&#123;&#125;</span></span><br><span class="line"><span class="comment"> * 2. 构造函数指向new的函数this.constructor = foo</span></span><br><span class="line"><span class="comment"> * 3. 该对象的原型链接到Foo.prototype</span></span><br><span class="line"><span class="comment"> * 4. 传入的参数赋给新对象</span></span><br><span class="line"><span class="comment"> * 之前看过new的三个步骤版本，以后整理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以接收参数作为新创建对象的属性</span></span><br><span class="line"><span class="keyword">var</span> baz = <span class="built_in">Object</span>.create()</span><br></pre></td></tr></table></figure><ul><li>原型的访问方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(foo)</span><br><span class="line">Foo.__proto__</span><br></pre></td></tr></table></figure><h2 id="第-2-章-函数"><a href="#第-2-章-函数" class="headerlink" title="第 2 章 函数"></a>第 2 章 函数</h2><h2 id="第-3-章-闭包"><a href="#第-3-章-闭包" class="headerlink" title="第 3 章 闭包"></a>第 3 章 闭包</h2><h2 id="第-4-章-强转"><a href="#第-4-章-强转" class="headerlink" title="第 4 章 强转"></a>第 4 章 强转</h2><ul><li>JavaScript 尝试将对象转换成字符串时，首先调用 toString()方法。如果不反悔基础类型，会调用 valueOf()函数。否则抛出 Typeerror 异常。转为数字时顺序相反。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span> + <span class="number">1</span>) <span class="comment">// "11"</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">"11"</span>) <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">""</span>)</span><br></pre></td></tr></table></figure><ul><li><p>在对象的原型链上定义 toString()和 valueOf()来定义强转时使用的函数，但是会出现先调用 valueOf()的情况。原因在于内部的机制：<code>如果一个对象能够转成多个基础类型，那么会使用可选参数PreferredType来指定类型。</code>由于没有指定内部默认值（DefaultValue）函数，JS 假设你想要一个数字。</p></li><li><p>数组的 valueOf()方法返回一个对象。</p></li><li><p>‘||’默认值、!!获得 Boolean 类型</p></li><li><p>立即调用函数表达式，前面加上一元运算符会把函数声明转成函数表达式，可以在后面接上括号进行调用。在写类库框架的时候常常把分号前置，以防止解析器意想不到的错误。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是一个函数声明'</span>)</span><br><span class="line">&#125;() <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'OK'</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><ul><li>>&gt;&gt;逻辑右移运算符，正负均补 0 ，详见计算机组成原理一书。</li></ul><p>-</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="literal">false</span> + [])[<span class="number">0</span>] === <span class="string">"f"</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>堆：堆是在内存中的顺序无关的容器，存放正在使用或未被垃圾回手清理的变量和对象的地方</li><li>帧：帧是时间循环周期中需要被执行的连续工作单元。帧包含把函数对象和堆中的变量链接在一起的执行上下文。</li><li>栈：事件循环栈包含了执行一个消息所需的所有连续的帧，事件循环自顶向下处理帧，有以来的帧把他们所依赖的帧添加到上面。</li><li>队列：队列是等待处理的消息的列表，每条消息都引用一个函数。当栈为空时，队列中最旧的消息作为底部帧被添加到栈中。</li></ul><p>有关宏任务微任务可以看<a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">这个</a>简单了解一下。</p><h2 id="第-7-章-风格"><a href="#第-7-章-风格" class="headerlink" title="第 7 章 风格"></a>第 7 章 风格</h2><ul><li>变量名、函用 camelCase，类使用 PascalCase，匈牙利命名法不是必须的，可用于表达对象是依赖于一个库或者框架构造的。</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">web worker</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;读《JavaScript-专家编程》&quot;&gt;&lt;a href=&quot;#读《JavaScript-专家编程》&quot; class=&quot;headerlink&quot; title=&quot;读《JavaScript 专家编程》&quot;&gt;&lt;/a&gt;读《JavaScript 专家编程》&lt;/h1&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Notes" scheme="http://lynnjs.com/categories/Notes/"/>
    
    
      <category term="Reading" scheme="http://lynnjs.com/tags/Reading/"/>
    
      <category term="Software Engineering" scheme="http://lynnjs.com/tags/Software-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>数值的表示</title>
    <link href="http://lynnjs.com/ck11ywqxi001av8fy5k6qn8ox/"/>
    <id>http://lynnjs.com/ck11ywqxi001av8fy5k6qn8ox/</id>
    <published>2018-08-17T00:33:27.000Z</published>
    <updated>2019-09-27T10:03:18.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数值的表示"><a href="#数值的表示" class="headerlink" title="数值的表示"></a>数值的表示</h1><blockquote><p>本文首先发布于<a href="https://fe-home.github.io/" target="_blank" rel="noopener">国双前端</a></p></blockquote><p>先上代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaSctipt</span></span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><p>如果你百度一下，就会知道几乎所有语言都会面临浮点数的精度问题，想要了解 IEEE754，要先了解计算机内部的定点数表示法。</p><h1 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h1><p>以八位机器数举例</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>  =&gt; <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">-10</span> =&gt; <span class="number">1000</span> <span class="number">1010</span></span><br></pre></td></tr></table></figure><p>原码就是把数值直接用二进制表示出来，正负号用末位 0，1 来表示。<br>原码有诸多弊端，比如：数值的减法不能用加法来计算。在十进制中 10-10 和 10+(-10)是等效的，但是在原码表示法的机器数运算中，10+(-10)却得到了 1001 0100 的结果，显然不等于 0 。在计算机内部，处理运算是用与或非门来控制的，加减法分别用两套电路有些浪费资源，我们能否用加法电路来实现减法呢？<br>其次，0 和-0 在原码中竟然是不同的表示法，但是这对运算并没有帮助，反而浪费了一个表示位置。</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>  =&gt; <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">-10</span> =&gt; <span class="number">1111</span> <span class="number">0110</span></span><br></pre></td></tr></table></figure><p>补码的正数和原码一样，但是负数采用原码的“取反加一”，也就是说，想要得到-10，首先把符号位确定为 1，然后写出 10 的原码表示，将其各个位置取反加一，即得到了该原码的补码。补码的求相反数同理。</p><p>此时 10+(-10)和 10-10 的操作统一了，同时也没有了+0 和-0 的区别。计算机内部运算一般采用补码来进行，感兴趣的可以了解一下定点数/浮点数的乘法/除法，仅用移位和加法运算即可完成。</p><p>补码的移位要注意一点，算术右移的时候正数补 0 负数补 1 。</p><p>移码、反码此处不涉及，了解即可。</p><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>为了扩大数的表示范围，可以采用“科学计数法”来表示大数或者小数。比如-2000 0000 就可以表示成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 * 2 * 10 ^ 7</span><br></pre></td></tr></table></figure><p>如果我们提前约定好了底数 10，那么我们表示这个数只需要三个信息，负号、2、7 ，转换成 2 进制就是 1 10 0111 比我们单独存储-20000000 要节省很多空间</p><p>由于 2 进制的限制，计算机内部这个约定好的底数是 2。</p><h2 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h2><p>目前计算机内部表示浮点数的一个标准就是 IEEE754，以 32 位计算机举例，表示 1100 0111 为 1 1000 0101 10001110000000000000000<br>乍一看可能觉得这种表示法更复杂了，其实无论在精度还是在表示数的范围，IEEE754 都是很优秀的。<br>在 IEEE754 中，底数为 2，用 1 位表示符号，8 位表示阶码，也就是上文中的 1000 0101，为了表示 2 的负数次方，阶码采用移码，都加上 127，这样负数的阶码也可以表示出来了，23 位原码表示尾数。<br>关于尾数这里要注意一点，由于 2 进制的有效数字第一位一定是 1，所以尾数的前面省略了一个 1 不写，用 23 位的尾数表示了 24 位的值，在手动转换的时候要自己补上。</p><p>说了这么多还是没有直接解答浮点数的精度问题，但是看过了以上之后，你会更容易理解。<br>首先计算机没有办法精确地表示 0.1 和 0.2 等等，因为通过 2 次幂来控制移位，计算机只能精确表示出 0.5、0.25、0.125、0.0625 等等，这些数是无论如何也不能表示出 0.1 这样的数的，只能随着尾数长度的增加而无限接近。而在计算机存储这样的数的时候就会用到舍入策略：</p><h1 id="舍入策略"><a href="#舍入策略" class="headerlink" title="舍入策略"></a>舍入策略</h1><p>IEEE 列出了四种不同的舍入方法：</p><blockquote><ul><li>舍入到最接近：舍入到最接近，在一样接近的情况下偶数优先（Ties To Even，这是默认的舍入方式）：会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中式以 0 结尾的）。</li><li>朝+∞ 方向舍入：会将结果朝正无限大的方向舍入。</li><li>朝-∞ 方向舍入：会将结果朝负无限大的方向舍入。</li><li>朝 0 方向舍入：会将结果朝 0 的方向舍入。</li></ul></blockquote><p>举个栗子<br>假如我们都采用朝+∞ 方向舍入，保留一位小数，那么 0.41 会入到 0.5，0.41+0.41 在计算机中就会计算成 1.（仅仅是假设，实际计算机精度大得多）<br>而在我们 let a = 0.3 的时候会把 0.3 转换成 2 进制存储进来，再进行读取的时候，由于它和 0.3 的差比机器内部最大舍入误差小，所以再进行输出的时候就会正常输出 0.3，在进行 0.1+0.2 的时候由于这种舍入误差的累积，导致了输出结果不等于 0.3 。</p><h1 id="不同语言的输出"><a href="#不同语言的输出" class="headerlink" title="不同语言的输出"></a>不同语言的输出</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%f"</span>,<span class="number">0.1</span>+<span class="number">0.2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 0.300000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">0.1</span>+<span class="number">0.2</span>);</span><br><span class="line">    <span class="comment">// 0.30000000000000004</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="keyword">print</span> <span class="number">0.1</span>+<span class="number">0.2</span></span><br><span class="line"><span class="comment"># 0.3</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="number">0.1</span>+<span class="number">0.2</span></span><br><span class="line">  <span class="comment">// 0.3</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ruby</span></span><br><span class="line">puts <span class="number">0</span>.<span class="number">1</span>+<span class="number">0</span>.<span class="number">2</span></span><br><span class="line"><span class="comment"># 0.30000000000000004</span></span><br></pre></td></tr></table></figure><p>不同语言由于在输出长度方面有区别，所以最后的 4 可能会被截断。</p><h1 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h1><p>在日常使用中一般不建议浮点数进行比较，一种比较的方法是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">abs</span>(a - b) ＜ <span class="number">1e-8</span></span><br><span class="line"><span class="comment">// 自行设置精度</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.wikipedia.org/zh-hans/IEEE_754" target="_blank" rel="noopener">IEEE 754_wikipedia</a><br><a href="https://www.amazon.cn/dp/B01N03IQK4/ref=sr_1_1?ie=UTF8&amp;qid=1534470551&amp;sr=8-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">深入理解计算机系统(原书第 3 版)</a><br><a href="https://www.amazon.cn/dp/B00HTIEY94/ref=sr_1_4?ie=UTF8&amp;qid=1534470571&amp;sr=8-4&amp;keywords=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">计算机组成原理-唐朔飞</a><br><a href="https://zhuanlan.zhihu.com/p/33494597" target="_blank" rel="noopener">js 中浮点数的表示及计算–IEEE 754</a><br><a href="https://www.imooc.com/article/23518" target="_blank" rel="noopener">原码补码反码移位</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数值的表示&quot;&gt;&lt;a href=&quot;#数值的表示&quot; class=&quot;headerlink&quot; title=&quot;数值的表示&quot;&gt;&lt;/a&gt;数值的表示&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文首先发布于&lt;a href=&quot;https://fe-home.github.io/&quot; t
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="http://lynnjs.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="IEEE754" scheme="http://lynnjs.com/tags/IEEE754/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法基础——KMP</title>
    <link href="http://lynnjs.com/ck11ywqxl001gv8fy8s25d2bu/"/>
    <id>http://lynnjs.com/ck11ywqxl001gv8fy8s25d2bu/</id>
    <published>2018-08-16T11:13:26.000Z</published>
    <updated>2019-09-27T10:03:18.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法基础-——-KMP"><a href="#数据结构与算法基础-——-KMP" class="headerlink" title="数据结构与算法基础 —— KMP"></a>数据结构与算法基础 —— KMP</h1><p>KMP 是一种优化的模式匹配算法，区别于暴力模式匹配算法 O(mn) 的时间复杂度，KMP通过优化回溯问题，其时间复杂度可以优化至 O(m+n)。</p><h2 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../img/kmp1.gif" alt="kmp1" title>                </div>                <div class="image-caption">kmp1</div>            </figure><p>可以发现，该算法在失配的时候会回退 i 值，造成时间复杂度增加，实际上在B和D失配的时候，子串是可以记录到D前一个字符串已经匹配成功的。</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../img/kmp2.gif" alt="kmp2" title>                </div>                <div class="image-caption">kmp2</div>            </figure><p>我们先分析模式串——ABCAD，如果在D位置失配了，那么可以获取到一个信息，D以前的都成功匹配了，也就是说字符串失配位置前一个是A，恰好可以和模式串开头的A进行匹配。</p><h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>首先我们要知道，一旦发生失配，j需要移动到模式串的哪个位置。</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>模式串</td><td>A</td><td>B</td><td>C</td><td>A</td><td>D</td></tr><tr><td>next[j]</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><h3 id="观察法"><a href="#观察法" class="headerlink" title="观察法"></a>观察法</h3><p><small>*考研的时候做题用的方法</small></p><p>先把第一第二个位置上的next标为-1,0，从第三位开始，观察模式串前部分和后部分相同的长度有多少(每次最多加1)，这么说可能比较抽象，举个栗子：<br>|     |     |     |     |     |     |  |<br>| — | — | — | — | — | — |–|<br>| 模式串 | A | B | A | B | C | A |<br>| next[j]| -1| 0 | 0 | 1 | 2 | 0 |</p><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> next = [<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">let</span> len = str.length</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (j &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k === <span class="number">-1</span> || str[j] === str[k]) &#123;</span><br><span class="line">      k++</span><br><span class="line">      j++</span><br><span class="line">      next[j] = k</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      k = next[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构与算法基础-——-KMP&quot;&gt;&lt;a href=&quot;#数据结构与算法基础-——-KMP&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法基础 —— KMP&quot;&gt;&lt;/a&gt;数据结构与算法基础 —— KMP&lt;/h1&gt;&lt;p&gt;KMP 是一种优化的模式匹配
      
    
    </summary>
    
      <category term="数据结构/算法" scheme="http://lynnjs.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="KMP" scheme="http://lynnjs.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>MpVue探坑日记</title>
    <link href="http://lynnjs.com/ck11ywqwi0005v8fyzunqhrk5/"/>
    <id>http://lynnjs.com/ck11ywqwi0005v8fyzunqhrk5/</id>
    <published>2018-08-15T14:05:22.000Z</published>
    <updated>2019-09-27T10:03:18.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MpVue-踩坑日记"><a href="#MpVue-踩坑日记" class="headerlink" title="MpVue 踩坑日记"></a>MpVue 踩坑日记</h1><p>近日将原有的原生小程序迁移到 Vue 技术栈中，遂采用<a href="http://mpvue.com/mpvue/" target="_blank" rel="noopener">mpvue</a>进行代码迁移和重构。建议将官方文档看一遍之后能避开大部分坑。</p><h1 id="img-标签"><a href="#img-标签" class="headerlink" title="img 标签"></a>img 标签</h1><p>img 标签的 src 属性无法指向相对路径，需要用绝对路径代替。详见：<a href="http://t.cn/RDuBSgR" target="_blank" rel="noopener">GitHub</a></p><h1 id="tabbar"><a href="#tabbar" class="headerlink" title="tabbar"></a>tabbar</h1><p><code>tabbar</code>中的图标设置，需要将图片文件放在<code>/static</code>中才可以正常引用。详见：<a href="https://github.com/Meituan-Dianping/mpvue/issues/94" target="_blank" rel="noopener">GitHub</a></p><h1 id="wx-指令转-v-指令"><a href="#wx-指令转-v-指令" class="headerlink" title="wx:指令转 v-指令"></a>wx:指令转 v-指令</h1><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>微信小程序的<code>wx:for</code>不需要指定 index，转到<code>v-for</code>之后需要指定 index。</p><h2 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h2><p>微信小程序的事件方法不能传参数，所以只能绑定在页面上，但是切换到 vue 就支持传参，因此可以去掉大部分的<code>data:XXX</code>绑定的语句。</p><h2 id="bindtap-等事件"><a href="#bindtap-等事件" class="headerlink" title="bindtap 等事件"></a>bindtap 等事件</h2><p>事件的转换参考官方文档，大部分的移动端事件可以支持。</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>目前 view 标签迁移到 div 标签没有发现问题。</p><h1 id="setData"><a href="#setData" class="headerlink" title="setData()"></a>setData()</h1><p>小程序中 setData 有两种应用场景，一种是赋值，一种是把自己的值重新赋给自己用于更新页面。在 Vue 中由于采用了双向绑定，因此直接采用<code>this.foo=bar</code>即可</p><h1 id="key"><a href="#key" class="headerlink" title=":key"></a>:key</h1><p>开发过程中遇到以下场景：通过 v-for 生成一系列自定义的组件，组件内部的 onload 方法里有一个语句会改变组件内部的值，现象是这个组件无限调用 onload 方法，导致调试器崩溃。<br>经过排查，原来的 v-for 语句后边绑定的<code>:key=&quot;Math.random(index)&quot;</code>会出现问题，改为<code>:key=&quot;index&quot;</code>问题解决。<br>使用 Math.random()绑定 key 值的原因在于，之前在练习 Vue 的时候，做了一个可添加删除的 TodoList，单纯地使用 inde 作为 key 值，在删除的时候出现了一个 bug，选中了 checkbox 的那一个条目删除之后，第二个条目的 index 值变成了前一个条目的 index 值，此时 vue 会认为这个 idnex 项可以复用，checkbox 的状态就被保留了，从此只使用两种方法进行 key 值的绑定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:key=<span class="string">"Date.now()+index"</span></span><br><span class="line">:key=<span class="string">"Math.random(index)"</span></span><br><span class="line"><span class="comment">// 窃以为Vue的一大败笔就是默认复用，反而造成了某些项目的资源浪费</span></span><br><span class="line"><span class="comment">// 核心方法UpdateChild()在以后的博客中会有涉及</span></span><br></pre></td></tr></table></figure><p>具体为什么 Math.random()绑定 key 值造成无限刷新，还没有结果。</p><h1 id="页面后退之后不销毁，数据缓存"><a href="#页面后退之后不销毁，数据缓存" class="headerlink" title="页面后退之后不销毁，数据缓存"></a>页面后退之后不销毁，数据缓存</h1><p>详见：<a href="https://github.com/Meituan-Dianping/mpvue/issues/140" target="_blank" rel="noopener">#140</a><br>解决方案：页面中添加生命周期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onUnload()&#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.$data, <span class="keyword">this</span>.$options.data())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐全局注册，因为有些页面其实是需要缓存的，只有在某些特定页面比如包含input标签</span></span><br></pre></td></tr></table></figure><h1 id="Vue-文件内的-scoped-style-标签"><a href="#Vue-文件内的-scoped-style-标签" class="headerlink" title="Vue 文件内的 scoped style 标签"></a>Vue 文件内的 scoped style 标签</h1><p>发现一个问题：<br>现象：在 vue 组件 ​​ 内部，带有 scoped 属性的 style 标签里，写 scss 嵌套样式，会出现第二层以上的样式失效。 ​<br>成因：vue 的 scoped 有如 ​​ 下规则：</p><blockquote><ol><li><p>给 HTML 的 DOM 节点加一个不重复 data 属性(形如：data-v-2311c06a)来表示他的唯一性</p></li><li><p>在每句 css 选择器的末尾（编译后的生成的 css 语句）加一个当前组件的 data 属性选择器（如[data-v-2311c06a]）来私有化样式</p></li><li><p>如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的 data 属性</p></li></ol></blockquote><p>以上会导致嵌套的选择器附加的 data 属性选择器会错误<br>网上找到的类似的情况有：<br><a href="https://blog.csdn.net/juse__we/article/details/80419617" target="_blank" rel="noopener">https://blog.csdn.net/juse__we/article/details/80419617</a><br><a href="https://www.jianshu.com/p/f9a8b7784655" target="_blank" rel="noopener">https://www.jianshu.com/p/f9a8b7784655</a><br><a href="https://github.com/vuejs/vue/issues/7067" target="_blank" rel="noopener">https://github.com/vuejs/vue/issues/7067</a><br>解决办法：养成好习惯，大段的嵌套样式在外部文件中，组件内 scoped 样式只写简单的非嵌套的样式</p><h1 id="MpVue-中使用-SCSS"><a href="#MpVue-中使用-SCSS" class="headerlink" title="MpVue 中使用 SCSS"></a>MpVue 中使用 SCSS</h1><p>使用官方的脚手架之后需要自行安装 node-sass 和<br>sass-loader</p><p><br><br><br><br><br></p><p><small><br>更新时间：2018 年 08 月 15 日 22:26:32<br></small></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MpVue-踩坑日记&quot;&gt;&lt;a href=&quot;#MpVue-踩坑日记&quot; class=&quot;headerlink&quot; title=&quot;MpVue 踩坑日记&quot;&gt;&lt;/a&gt;MpVue 踩坑日记&lt;/h1&gt;&lt;p&gt;近日将原有的原生小程序迁移到 Vue 技术栈中，遂采用&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="Coding" scheme="http://lynnjs.com/categories/Coding/"/>
    
    
      <category term="Dev" scheme="http://lynnjs.com/tags/Dev/"/>
    
      <category term="MpVue" scheme="http://lynnjs.com/tags/MpVue/"/>
    
      <category term="微信小程序" scheme="http://lynnjs.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>工作心得#第肆周</title>
    <link href="http://lynnjs.com/ck11ywqxf0016v8fyf8u2ubhf/"/>
    <id>http://lynnjs.com/ck11ywqxf0016v8fyf8u2ubhf/</id>
    <published>2018-08-05T03:28:26.000Z</published>
    <updated>2019-09-27T10:03:18.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作心得-第四周"><a href="#工作心得-第四周" class="headerlink" title="工作心得 #第四周"></a>工作心得 #第四周</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式在春天求职的时候就有学过，但是一直都没有扎实地记住。这周又重新仔细看了一遍 =&gt; <a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">这篇文章</a>，果然还是不能功利地学习啊……</p><p>在学习的时候，我把正则表达式的元素分成两类， 字符类型和字符数量。<br>字符类型分为匹配字符和匹配位置。字符数量分为 0,1,n 次。<br>还有关于分组什么的单独学习吧。</p><h2 id="Chrome-Dev-Tools"><a href="#Chrome-Dev-Tools" class="headerlink" title="Chrome Dev Tools"></a>Chrome Dev Tools</h2><p>用 JS 刷 LeetCode 的时候，debug 就全靠 Chrome Dev Tools 了，但是这个小工具其实还有很多隐藏功能。参考<a href="http://www.css88.com/doc/chrome-devtools/" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="Markdown-格式"><a href="#Markdown-格式" class="headerlink" title="Markdown 格式"></a>Markdown 格式</h2><p><a href="http://xianbai.me/learn-md/article/about/readme.html" target="_blank" rel="noopener">MarkDown GitBook</a></p><h2 id="localStorage-sessionStorage"><a href="#localStorage-sessionStorage" class="headerlink" title="localStorage/sessionStorage"></a>localStorage/sessionStorage</h2><p>调试的时候在 Dev Tools 的 Application 选项卡中就可以找到。调用的时候用以下方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">"Foo"</span>, Bar)</span><br><span class="line">localStorage.getItem(<span class="string">"Baz"</span>)</span><br><span class="line">localStorage.clear()</span><br><span class="line">localStorage.removeItem(<span class="string">"Qux"</span>)</span><br></pre></td></tr></table></figure><h2 id="escape-encodeURI-encodeURIComponent"><a href="#escape-encodeURI-encodeURIComponent" class="headerlink" title="escape()/encodeURI()/encodeURIComponent()"></a>escape()/encodeURI()/encodeURIComponent()</h2><p>区别见<a href="https://www.zhihu.com/question/21861899" target="_blank" rel="noopener">这里</a></p><h2 id="判断-undefined-null-NaN"><a href="#判断-undefined-null-NaN" class="headerlink" title="判断 undefined/null/NaN"></a>判断 undefined/null/NaN</h2><p><a href="https://www.jianshu.com/p/742af5f7d671" target="_blank" rel="noopener">This</a></p><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h2 id="async-await-实践"><a href="#async-await-实践" class="headerlink" title="async/await 实践"></a>async/await 实践</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工作心得-第四周&quot;&gt;&lt;a href=&quot;#工作心得-第四周&quot; class=&quot;headerlink&quot; title=&quot;工作心得 #第四周&quot;&gt;&lt;/a&gt;工作心得 #第四周&lt;/h1&gt;&lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Coding" scheme="http://lynnjs.com/categories/Coding/"/>
    
    
      <category term="Dev" scheme="http://lynnjs.com/tags/Dev/"/>
    
  </entry>
  
  <entry>
    <title>读《构建之法：现代软件工程》 #2</title>
    <link href="http://lynnjs.com/ck11ywqxz002dv8fybqvfbt2p/"/>
    <id>http://lynnjs.com/ck11ywqxz002dv8fybqvfbt2p/</id>
    <published>2018-07-22T03:43:38.000Z</published>
    <updated>2019-09-27T10:03:18.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《构建之法：现代软件工程》-2"><a href="#《构建之法：现代软件工程》-2" class="headerlink" title="《构建之法：现代软件工程》 #2"></a>《构建之法：现代软件工程》 #2</h1><h2 id="Agree"><a href="#Agree" class="headerlink" title="Agree"></a><font color="green">Agree</font></h2><h3 id="8-5-功能的定位和优先级"><a href="#8-5-功能的定位和优先级" class="headerlink" title="8.5 功能的定位和优先级"></a>8.5 功能的定位和优先级</h3><p>这个老师上课的时候有详细讲过，关于“惊喜”“核心功能”和“基本功能”随投资力度和产品质量变化而增长的趋势。</p><h3 id="12-1-1-用户体验的第一印象"><a href="#12-1-1-用户体验的第一印象" class="headerlink" title="12.1.1 用户体验的第一印象"></a>12.1.1 用户体验的第一印象</h3><blockquote><p>5W1H 原则：Who、When、Where、What、Why、How</p><p>谁是你的目标用户？</p><p>他们会在什么时候使用你的产品？</p><p>目标用户会在哪里和你的产品交互？</p><p>你的产品是什么？用户期待的是什么？</p><p>用户为什么要使用你的产品？在众多的竞争产品中，用户为什么要选择你的产品？</p><p>用户是如何与你的产品  进行交互的？</p></blockquote><h3 id="12-1-3-软件服务始终都要记得用户的选择"><a href="#12-1-3-软件服务始终都要记得用户的选择" class="headerlink" title="12.1.3 软件服务始终都要记得用户的选择"></a>12.1.3 软件服务始终都要记得用户的选择</h3><p>描述了以下问题：</p><blockquote><p>用户上了银行的门户网站，把语言改成英文，但是发来的手机验证码是中文的，而且在用户的手机上显示乱码。</p></blockquote><h3 id="12-2-用户体验设计的步骤和目标"><a href="#12-2-用户体验设计的步骤和目标" class="headerlink" title="12.2 用户体验设计的步骤和目标"></a>12.2 用户体验设计的步骤和目标</h3><blockquote><p>需要指出的是，软件工程师往往以熟练掌握任职阻力大的工具而自豪(如命令行，Vim，EMACS 等)……</p></blockquote><h2 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a><font color="blue">Notice</font></h2><h3 id="8-6-3-提高估计能力的招数"><a href="#8-6-3-提高估计能力的招数" class="headerlink" title="8.6.3 提高估计能力的招数"></a>8.6.3 提高估计能力的招数</h3><blockquote><p>Y=X±X÷N（对某件事情的估计时间 X，做过类似开发工作的次数 N）</p></blockquote><h3 id="9-4-领导力——搞笑的团队讨论"><a href="#9-4-领导力——搞笑的团队讨论" class="headerlink" title="9.4 领导力——搞笑的团队讨论"></a>9.4 领导力——搞笑的团队讨论</h3><blockquote><p>“对，而且……”<br>“好，但是……”</p></blockquote><h3 id="图-9-7-创业公司失败的主要原因"><a href="#图-9-7-创业公司失败的主要原因" class="headerlink" title="图 9.7 创业公司失败的主要原因"></a>图 9.7 创业公司失败的主要原因</h3><p>其中没有实际的市场需求占 42%</p><h3 id="图-11-5-开发人员的标准开发流程"><a href="#图-11-5-开发人员的标准开发流程" class="headerlink" title="图 11.5 开发人员的标准开发流程"></a>图 11.5 开发人员的标准开发流程</h3><h3 id="12-3-用户体验评价标准"><a href="#12-3-用户体验评价标准" class="headerlink" title="12.3 用户体验评价标准"></a>12.3 用户体验评价标准</h3><blockquote><ol><li>尽快提供可感触的反馈</li><li>系统界面符合用户的现实惯例</li><li>用户拥有控制权</li><li>一致性和标准化</li><li>适合各种类型的用户</li><li>帮助用户识别、诊断并修复错误</li><li>有必要的提示和帮助文档</li></ol></blockquote><h2 id="Warning-Question"><a href="#Warning-Question" class="headerlink" title="Warning/Question"></a><font color="yellow">Warning/Question</font></h2><h3 id="FDD-的规范描述"><a href="#FDD-的规范描述" class="headerlink" title="FDD 的规范描述"></a>FDD 的规范描述</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《构建之法：现代软件工程》-2&quot;&gt;&lt;a href=&quot;#《构建之法：现代软件工程》-2&quot; class=&quot;headerlink&quot; title=&quot;《构建之法：现代软件工程》 #2&quot;&gt;&lt;/a&gt;《构建之法：现代软件工程》 #2&lt;/h1&gt;&lt;h2 id=&quot;Agree&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Notes" scheme="http://lynnjs.com/categories/Notes/"/>
    
    
      <category term="Reading" scheme="http://lynnjs.com/tags/Reading/"/>
    
      <category term="Software Engineering" scheme="http://lynnjs.com/tags/Software-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>读《社会契约论》 #1</title>
    <link href="http://lynnjs.com/ck11ywqxw0028v8fyce5kq38g/"/>
    <id>http://lynnjs.com/ck11ywqxw0028v8fyce5kq38g/</id>
    <published>2018-07-20T13:39:45.000Z</published>
    <updated>2019-09-27T10:03:18.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读《社会契约论》"><a href="#读《社会契约论》" class="headerlink" title="读《社会契约论》"></a>读《社会契约论》</h1><p>去年考研的时候才算是真真正正地学过一次哲学，但是仅仅从一个角度（马克思主义）来进行学习的。所以有关于哲学方面的问题仅做摘抄，不做深入讨论。</p><p>本书是由李平沤译、商务印书馆出版的，<a href="https://www.amazon.cn/dp/B004X3XPY8/ref=sr_1_1?ie=UTF8&amp;qid=1532244668&amp;sr=8-1&amp;keywords=%E7%A4%BE%E4%BC%9A%E5%A5%91%E7%BA%A6%E8%AE%BA" target="_blank" rel="noopener">《社会契约论》——Amazon.cn</a>。</p><p>网上还有何兆武版，有机会再读。</p><h2 id="译者前言"><a href="#译者前言" class="headerlink" title="译者前言"></a>译者前言</h2><blockquote><p>卢梭的《社会契约论》探讨的是政治权力的原理，它的主旨是为人民民主主权的建立奠定理论基础。</p><p>“我把我的一生献给真理”——卢梭</p></blockquote><h2 id="第一卷"><a href="#第一卷" class="headerlink" title="第一卷"></a>第一卷</h2><blockquote><p>我不打算从阐明我所研究的问题的重要性论起，我要开门见山，一下笔就直接阐明主题。人们也许会问我是不是一位国君或立法者，因此才著书论述政治问题？我回答说：不是；而且，正是因为我这两者都不是，所以我才要谈论政治。如果我是国君或立法者，我就不会浪费时间谈论应当做些什么事了。该做些什么事，我会去做的，否则，我就什么话也不说。</p></blockquote><h3 id="第一章-第一卷的题旨"><a href="#第一章-第一卷的题旨" class="headerlink" title="第一章 第一卷的题旨"></a>第一章 第一卷的题旨</h3><blockquote><p>人生来是自由的，但却无处不身戴枷锁。自以为是其他一切的主人，反而比其他一切更是奴隶。</p></blockquote><h3 id="第二章-论原始社会"><a href="#第二章-论原始社会" class="headerlink" title="第二章 论原始社会"></a>第二章 论原始社会</h3><blockquote><p>在所有各种各样的社会中，最古老而又唯一是自然形成的社会，是家庭。孩子只有在他们需要父亲养育他们的时候，才依附他们的父亲，而一旦没有这种需要了，他们之间的自然联系便宣告解体。孩子解除了他们对父亲应有的服从，而父亲也免除了他对孩子应有的关怀，双方都同样进人了独立状态。如果他们还继续联系在一起的话，那就不再是自然的，而是自愿的，这时，家庭本身便只有靠约定来维系。这种人人都有的自由，产生于人的天性。人的天性的首要法则是保护他自己的生存；他首先关心的，是照护好他自己。一当他到了有理智的年龄，那就只有他本人才能判断应当采用何种方法才最能维护他的存在。从这个时候起，他就成为他自己的主从以上的叙述来看，我们可以说家庭是政治社会的原始模型。政治社会的首领就好比一个家庭中的父亲，人民好比家中的子女；大家生来都是平等的和自由的，每个人都只有在对自己有利的时候才转让自己的自由 b 全部区别在于，在家庭中，父亲对子女的爱表现在他对子女的关心，从对子女的关心中得到乐趣；而在国家中，首领对人民没有这种父爱；他所关心的是如何统治人民，他以统治人民为乐。</p></blockquote><blockquote><p>卢梭早在 1755 年就批驳了有些学者认为专制政治和整个社会都是由父权派生出来的谬论。他说：“我们用不着去引用洛克和席德尼的相反的论点，只需指出这一点就够了：在世界上再也没有什么东西比父权的温柔与专制主义的暴虐更大相径庭了，因为父权的行使，给服从父权的人带来的好处，比行使父权的人得到的好处大得多。按照自然法，父亲只是在他的孩子需要他帮助的时候，他才是孩子的主人，过了这段期间，他们就是平等的，孩子便完全脱离父亲而独立·他们对于父亲只有尊敬的义务，而没有服从的义务，因为报答父母固然是一种应尽的义务，但不是一种可以强迫索取的权利。我们不仅不能说文明社会是由父权产生的，相反，我们应当说父权的主要力量来源于社会。”（卢梭：《论人与人之间不平等的起因和基础》，李平沤译，商务印书馆 2009 年版，第 106 一 107 页）</p></blockquote><h3 id="第三章-论最强者的权利"><a href="#第三章-论最强者的权利" class="headerlink" title="第三章 论最强者的权利"></a>第三章 论最强者的权利</h3><blockquote><p>强力构不成权利，人们只是对合法的权威才有义务服从。</p></blockquote><h3 id="第四章-论奴隶制"><a href="#第四章-论奴隶制" class="headerlink" title="第四章 论奴隶制"></a>第四章 论奴隶制</h3><blockquote><p>放弃自己的自由，就是放弃自己做人的资格，就是放弃做人的权利，甚至就是放弃自己的义务。……这样一种既不等价又无交换的条件，难道不表明它本身是无效的吗？因为，既然我得奴隶所有的一切都属于我，既然他的权力就是我的权力，他还有什么权利反对我？</p><p>可见战争绝对不是个人与个人的关系，而是国家与国家的关系。……如果未向某个国家的君主宣战便抢劫、杀害或关押该国的居民，那他就不是敌人，而是强盗。</p><p>因此战胜国有权处死那个国家的保卫者，只要他们手执武器抵抗。但是，一旦他们放下武器投降，不再当敌人或者敌人的工具了，他们便重新成为一般的人了，人们就没有权利伤害他们的生命。</p><p>有时候人们可以消灭一个国家的政权，但不消灭那个国家的任何一个成员。</p></blockquote><h3 id="第五章-论总需追溯到一个原始的约定"><a href="#第五章-论总需追溯到一个原始的约定" class="headerlink" title="第五章 论总需追溯到一个原始的约定"></a>第五章 论总需追溯到一个原始的约定</h3><blockquote><p>事实上，如果没有事先约定的话，除非选举的结果是全体致的，否则，少数人何以必须服从多数人的选择呢？那一百个选某人为首领的人凭什么权利替那十个不选那位首领的人投票呢？少数服从多数这个法则，其本身就是一种约定，表明至少有一次是全体一致的。</p></blockquote><h3 id="第六章-论社会公约"><a href="#第六章-论社会公约" class="headerlink" title="第六章 论社会公约"></a>第六章 论社会公约</h3><blockquote><p>“创建一种能以全部共同的力量来维护和保庫每个结合者的人身和财产的结合形式，使每一个在这种结合形式下与全体相联合的人所服从的只不过是他本人，而且同以往一样的自由。”社会契约所要解决的，就是这个根本问题。</p></blockquote><blockquote><p>这样一来，如果我们把社会公约中非本质的东西都排除掉，社会公约就可简化成如下的词句：我们每一个人都把我们自身和我们的全部力量置于公意的最高指导之下，而且把共同体中的每个成员都接纳为全体不可分割的一部分。</p></blockquote><h3 id="第七章-论主权者"><a href="#第七章-论主权者" class="headerlink" title="第七章 论主权者"></a>第七章 论主权者</h3><h3 id="第八章-论社会状态"><a href="#第八章-论社会状态" class="headerlink" title="第八章 论社会状态"></a>第八章 论社会状态</h3><h3 id="第九章-论财产权"><a href="#第九章-论财产权" class="headerlink" title="第九章 论财产权"></a>第九章 论财产权</h3><blockquote><p>现在让我用这样一句足以构成一切社会制度的基础的话来结束本章和本卷：“基本公约不仅没有摧毁自然的平等，反而以道德的和法律的平等来代替自然所造成人与人之间的身体上的不平等．，因而，虽然人与人之间在体力和智力上不相等，但由于公约和权利的保证，他们人人都是平等的。”</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;读《社会契约论》&quot;&gt;&lt;a href=&quot;#读《社会契约论》&quot; class=&quot;headerlink&quot; title=&quot;读《社会契约论》&quot;&gt;&lt;/a&gt;读《社会契约论》&lt;/h1&gt;&lt;p&gt;去年考研的时候才算是真真正正地学过一次哲学，但是仅仅从一个角度（马克思主义）来进行学习的。所
      
    
    </summary>
    
      <category term="Notes" scheme="http://lynnjs.com/categories/Notes/"/>
    
    
      <category term="Reading" scheme="http://lynnjs.com/tags/Reading/"/>
    
      <category term="哲学" scheme="http://lynnjs.com/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>读《构建之法：现代软件工程》 #1</title>
    <link href="http://lynnjs.com/ck11ywqxy002bv8fygxmizeen/"/>
    <id>http://lynnjs.com/ck11ywqxy002bv8fygxmizeen/</id>
    <published>2018-07-15T10:56:31.000Z</published>
    <updated>2019-09-27T10:03:18.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《构建之法——现代软件工程》-1"><a href="#《构建之法——现代软件工程》-1" class="headerlink" title="《构建之法——现代软件工程》 #1"></a>《构建之法——现代软件工程》 #1</h1><p>刚刚入职，想通过一本书快速地复习软件工程，来熟悉工作中的敏捷开发流程。或许能为团队在流程规范化上尽一份力。</p><p>在阅读的时候随时在书上做标记，分别有以下含义：</p><font color="green">Agree</font> <font color="blue">Notice</font> <font color="yellow">Warning/Question</font> <font color="red">Disagree</font><p>计划用四周时间完成阅读和笔记。</p><h2 id="Agree"><a href="#Agree" class="headerlink" title="Agree"></a><font color="green">Agree</font></h2><h3 id="1-2-3-软件工程的知识领域-P14"><a href="#1-2-3-软件工程的知识领域-P14" class="headerlink" title="1.2.3 软件工程的知识领域 P14"></a>1.2.3 软件工程的知识领域 P14</h3><p>没有银弹：</p><blockquote><p>“不会有任何单一软件工程上的突破，能够让程序开发的生产力得到一个数量级的提升。”</p></blockquote><p>霍夫斯塔特定律：</p><blockquote><p>“实际时间总是比预期的要长，即便你考虑了霍夫斯塔特定律。”</p></blockquote><blockquote><p>“向进度落后的项目中增加人员，会让项目更加落后。”</p></blockquote><h3 id="3-1-个人能力的衡量与发展-P47"><a href="#3-1-个人能力的衡量与发展-P47" class="headerlink" title="3.1 个人能力的衡量与发展 P47"></a>3.1 个人能力的衡量与发展 P47</h3><blockquote><p>软件工程师不能按时交付的原因，是他们有时候不满足于“解决目前直接的问题”，而是想“解决问题背后的问题”，或者是“解决通用的、不直接的，但有重大意义的问题”。</p></blockquote><p>十分认同。常常有以下两种情景存在：</p><ol><li>实现时注意到之前解决方案不够“完美”（如样式）</li><li>实现方法和以往实现思路有冲突或可完善（如提取出函数）</li></ol><h3 id="4-5-3-不间断地复审-P80"><a href="#4-5-3-不间断地复审-P80" class="headerlink" title="4.5.3 不间断地复审 P80"></a>4.5.3 不间断地复审 P80</h3><blockquote><p>“每个人每天的高效率工作时段不超过3-4个小时”</p></blockquote><p>认同。对于我来说，每天上午10-11点，下午2-5点思路最清晰，甚至每天都感觉不到这个时间段的存在。沉浸式的编码虽然享受，但是非常消耗精力，五点钟过后整个大脑都无法有条理的思考。（也许是饿的）</p><h3 id="4-6-2-如何正确地给予反馈-P85"><a href="#4-6-2-如何正确地给予反馈-P85" class="headerlink" title="4.6.2 如何正确地给予反馈 P85"></a>4.6.2 如何正确地给予反馈 P85</h3><blockquote><p>图 4-2 评论别人的三种层次</p><h4 id="最外层：行为和后果"><a href="#最外层：行为和后果" class="headerlink" title="最外层：行为和后果"></a>最外层：行为和后果</h4><p>“你迟到了，让我很着。我们错过了表演！”</p><h4 id="中间层：习惯和动机"><a href="#中间层：习惯和动机" class="headerlink" title="中间层：习惯和动机"></a>中间层：习惯和动机</h4><p>“你怎么又放我鸽子，你总是不重视我！”</p><h4 id="最内层：本质和固有属性"><a href="#最内层：本质和固有属性" class="headerlink" title="最内层：本质和固有属性"></a>最内层：本质和固有属性</h4><p>“你太自私了，你们XXX村的男人没一个好东西！”</p></blockquote><p>认同。</p><p>从小到大这种人真的太多了，说白了就是“上纲上线”，你不顺我心了，好你就是自私，你全家都自私。第三层涉及到人的本质属性，比如自私、地域等，对这个方面进行攻击连解释的机会都没有。</p><h2 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a><font color="blue">Notice</font></h2><h3 id="2-4-实践——设计有实际意义的软件工程作业-P37"><a href="#2-4-实践——设计有实际意义的软件工程作业-P37" class="headerlink" title="2.4 实践——设计有实际意义的软件工程作业 P37"></a>2.4 实践——设计有实际意义的软件工程作业 P37</h3><p>SRP,DCP</p><blockquote><p>SRP(Single Responsibility Principle)单一职责原则指出：</p><p>“一个模块（类）应该只有一个导致它变化的原因，一个模块应该完全对某个功能负责。”</p><p>OCP(Open-Close Principle)开放-封闭原则：</p><p>“软件实体应该是可扩展的，同时是不可修改的。”</p></blockquote><p>这两个原则过于“理想”。事实上经常需要模块对于新需求来进行更改。例如封装好的图表或者组件库，如果想单纯地在组件上添加新需求，就需要修改组件内的编码。</p><p>个人认为SRP和OCP只能在小型模块中实现，而在大型系统中这么做就难免陷入到被细碎的小模块淹没的情况。</p><h2 id="Warning-Question"><a href="#Warning-Question" class="headerlink" title="Warning/Question"></a><font color="yellow">Warning/Question</font></h2><h3 id="案例2——P59"><a href="#案例2——P59" class="headerlink" title="案例2——P59"></a>案例2——P59</h3><p>问题描述：</p><blockquote><p>程序员小飞原计划三天完成某个任务，他说服了同事，坚持采用自己独特的实现方法。现在是第三天下午，它马上就可以做完，但是在实现的过程中他越来越意识到自己原来设计中的弱点，他应该采取另一个办法，才能避免后面集成阶段的额外任务。但是如果现在就改弦更张，那就意味着公开承认自己的设计不好，并且会花费额外的时间。如果他按部就班地完成，最后整个团队还要花更多的时间在集成上，但那就不是他个人的问题了。怎么办？</p></blockquote><p>如果是我可能会加班改方案吧……但是一定要跟人确定改之后的是可行的。</p><h2 id="Disagree"><a href="#Disagree" class="headerlink" title="Disagree"></a><font color="red">Disagree</font></h2><h3 id="4-3-2-代码设计规范-goto-P69"><a href="#4-3-2-代码设计规范-goto-P69" class="headerlink" title="4.3.2 代码设计规范-goto P69"></a>4.3.2 代码设计规范-goto P69</h3><p>文中写到：</p><blockquote><p>函数最好有单一的出口，为了达到这一目的，可以使用goto。</p></blockquote><p>一般不推荐使用goto函数，goto并不能让逻辑清晰，反而会掩盖逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《构建之法——现代软件工程》-1&quot;&gt;&lt;a href=&quot;#《构建之法——现代软件工程》-1&quot; class=&quot;headerlink&quot; title=&quot;《构建之法——现代软件工程》 #1&quot;&gt;&lt;/a&gt;《构建之法——现代软件工程》 #1&lt;/h1&gt;&lt;p&gt;刚刚入职，想通过一本书快
      
    
    </summary>
    
      <category term="Notes" scheme="http://lynnjs.com/categories/Notes/"/>
    
    
      <category term="Reading" scheme="http://lynnjs.com/tags/Reading/"/>
    
      <category term="Software Engineering" scheme="http://lynnjs.com/tags/Software-Engineering/"/>
    
  </entry>
  
</feed>
